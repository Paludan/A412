\subsection{main.\+c File Reference}
\label{main_8c}\index{main.\+c@{main.\+c}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$dirent.\+h$>$}\\*
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct {\bf note}
\item 
struct {\bf data}
\item 
struct {\bf points}
\item 
struct {\bf mood\+Weighting}
\item 
struct {\bf event\+Placement}
\end{DoxyCompactItemize}
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bf C\+H\+A\+R\+S}~1000
\item 
\#define {\bf S\+C\+A\+L\+E\+S\+I\+Z\+E}~7
\end{DoxyCompactItemize}
\subsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef enum {\bf mode} {\bf mode}
\item 
typedef enum {\bf tone} {\bf tone}
\item 
typedef enum {\bf mood} {\bf mood}
\end{DoxyCompactItemize}
\subsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf mode} \{ {\bf major}, 
{\bf minor}
 \}
\item 
enum {\bf tone} \{ \\*
{\bf C}, 
{\bf Csharp}, 
{\bf D}, 
{\bf Dsharp}, 
\\*
{\bf E}, 
{\bf F}, 
{\bf Fsharp}, 
{\bf G}, 
\\*
{\bf Gsharp}, 
{\bf A}, 
{\bf Asharp}, 
{\bf B}
 \}
\item 
enum {\bf mood} \{ {\bf glad}, 
{\bf sad}
 \}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf check\+Directory} (char $\ast$, D\+I\+R $\ast$)
\item 
void {\bf find\+Note\+Length} (double x, int $\ast$, int $\ast$)
\item 
void {\bf print\+Note} ({\bf note})
\item 
int {\bf get\+Hex} (F\+I\+L\+E $\ast$, int[$\,$])
\item 
void {\bf fill\+Song\+Data} ({\bf data} $\ast$, int[$\,$], int)
\item 
int {\bf count\+Notes} (int[$\,$], int)
\item 
void {\bf fill\+Note} (int, {\bf note} $\ast$)
\item 
void {\bf print\+Song\+Data} ({\bf data})
\item 
void {\bf setting\+Points} (int $\ast$, int $\ast$, int $\ast$, int $\ast$, {\bf data}, int, {\bf note}[$\,$], int $\ast$)
\item 
void {\bf insert\+Moods} ({\bf mood\+Weighting}[$\,$], F\+I\+L\+E $\ast$)
\item 
void {\bf weighting\+Matrix} ({\bf mood\+Weighting}[$\,$], int, int, int, int, int $\ast$)
\item 
void {\bf find\+Events} (int, int[$\,$], {\bf event\+Placement}[$\,$], {\bf note}[$\,$], int $\ast$)
\item 
void {\bf insert\+Placement1} (int[$\,$], int $\ast$, int, {\bf note}[$\,$], int $\ast$, int[$\,$])
\item 
void {\bf insert\+Placement2} (int[$\,$], int $\ast$, int)
\item 
int {\bf check\+Next\+Event} (int[$\,$], int)
\item 
void {\bf find\+Ticks} (int, int[$\,$], {\bf event\+Placement}[$\,$], {\bf note}[$\,$], int, int $\ast$, int[$\,$])
\item 
void {\bf count\+Ticks1} (int[$\,$], int $\ast$, int, {\bf note}[$\,$], int $\ast$)
\item 
void {\bf count\+Ticks2} (int[$\,$], int $\ast$, int, {\bf note}[$\,$], int $\ast$)
\item 
int {\bf sort\+Result} (const void $\ast$, const void $\ast$)
\item 
void {\bf delta\+Time\+To\+Note\+Length} (int, int, {\bf note} $\ast$)
\item 
int {\bf is\+In\+Scale} (int, int[$\,$], int)
\item 
int {\bf is\+In\+Minor} (int)
\item 
int {\bf is\+In\+Major} (int)
\item 
int {\bf sort\+Toner} (const void $\ast$, const void $\ast$)
\item 
void {\bf find\+Mode} ({\bf note} $\ast$, int, {\bf data} $\ast$)
\item 
int {\bf Find\+Mood\+Amount} (F\+I\+L\+E $\ast$)
\item 
void {\bf print\+Results} (int, int, int, int, {\bf mood\+Weighting}[$\,$], int[$\,$])
\item 
int {\bf main} (int argc, const char $\ast$argv[$\,$])
\item 
int {\bf sort\+Tones} (const void $\ast$a, const void $\ast$b)
\item 
void {\bf check\+Scale} (int scales[$\,$], int {\bf tone}, int key)
\item 
void {\bf find\+Mode} ({\bf note} note\+Ar[$\,$], int total\+Notes, {\bf data} $\ast${\bf data})
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int {\bf A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}
\end{DoxyCompactItemize}


\subsubsection{Macro Definition Documentation}
\index{main.\+c@{main.\+c}!C\+H\+A\+R\+S@{C\+H\+A\+R\+S}}
\index{C\+H\+A\+R\+S@{C\+H\+A\+R\+S}!main.\+c@{main.\+c}}
\paragraph[{C\+H\+A\+R\+S}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+H\+A\+R\+S~1000}\label{main_8c_a5d7cfaaf3d71eb89b31364adb9fda6a6}
\index{main.\+c@{main.\+c}!S\+C\+A\+L\+E\+S\+I\+Z\+E@{S\+C\+A\+L\+E\+S\+I\+Z\+E}}
\index{S\+C\+A\+L\+E\+S\+I\+Z\+E@{S\+C\+A\+L\+E\+S\+I\+Z\+E}!main.\+c@{main.\+c}}
\paragraph[{S\+C\+A\+L\+E\+S\+I\+Z\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+C\+A\+L\+E\+S\+I\+Z\+E~7}\label{main_8c_a3c7b5c7d1b09d118aa63ec87e3c73a8b}


\subsubsection{Typedef Documentation}
\index{main.\+c@{main.\+c}!mode@{mode}}
\index{mode@{mode}!main.\+c@{main.\+c}}
\paragraph[{mode}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf mode}  {\bf mode}}\label{main_8c_abcec22444f1b2fc64f59764d40244d9f}
\index{main.\+c@{main.\+c}!mood@{mood}}
\index{mood@{mood}!main.\+c@{main.\+c}}
\paragraph[{mood}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf mood}  {\bf mood}}\label{main_8c_a3e304bbd72e3a576384c6e8cdb661eb4}
\index{main.\+c@{main.\+c}!tone@{tone}}
\index{tone@{tone}!main.\+c@{main.\+c}}
\paragraph[{tone}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf tone}  {\bf tone}}\label{main_8c_aac01cecf1f254ffa121e2715527a6a5a}


\subsubsection{Enumeration Type Documentation}
\index{main.\+c@{main.\+c}!mode@{mode}}
\index{mode@{mode}!main.\+c@{main.\+c}}
\paragraph[{mode}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mode}}\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{major@{major}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!major@{major}}\item[{\em 
major\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167adc8c3476e4d3526d10210987c7131cb5}
}]\index{minor@{minor}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!minor@{minor}}\item[{\em 
minor\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167a252026d6db6e81a42ef18bfd98b45a11}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00026 \{major, minor\} mode;
\end{DoxyCode}
\index{main.\+c@{main.\+c}!mood@{mood}}
\index{mood@{mood}!main.\+c@{main.\+c}}
\paragraph[{mood}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mood}}\label{main_8c_a845e01d4d631be8d8fac14b162607e7f}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{glad@{glad}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!glad@{glad}}\item[{\em 
glad\label{main_8c_a845e01d4d631be8d8fac14b162607e7fa55170d14edc722ae6672132bd212a19d}
}]\index{sad@{sad}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!sad@{sad}}\item[{\em 
sad\label{main_8c_a845e01d4d631be8d8fac14b162607e7fa545d9f58d50a21cb0f1a64155ec91a05}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00028 \{glad, sad\} mood;
\end{DoxyCode}
\index{main.\+c@{main.\+c}!tone@{tone}}
\index{tone@{tone}!main.\+c@{main.\+c}}
\paragraph[{tone}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tone}}\label{main_8c_aeb761eda34d47c3e64ca804875fd919f}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{C@{C}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!C@{C}}\item[{\em 
C\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa739ce3f516592d245d16fd8a3893472c}
}]\index{Csharp@{Csharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Csharp@{Csharp}}\item[{\em 
Csharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa443d44cb35267bc4445499d568e4bd26}
}]\index{D@{D}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!D@{D}}\item[{\em 
D\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa77a6b11f9898c052926f1d49765861e8}
}]\index{Dsharp@{Dsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Dsharp@{Dsharp}}\item[{\em 
Dsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fad3b2877ea9dc7d69bd1b52477a01a68b}
}]\index{E@{E}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!E@{E}}\item[{\em 
E\label{main_8c_aeb761eda34d47c3e64ca804875fd919fab199e021998d49b1f09338d8b9b18ecb}
}]\index{F@{F}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!F@{F}}\item[{\em 
F\label{main_8c_aeb761eda34d47c3e64ca804875fd919faf382a63cc3d6491bf26b59e66f46826d}
}]\index{Fsharp@{Fsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Fsharp@{Fsharp}}\item[{\em 
Fsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fad4ad1b6a094e98ff41e6e4f366769fc3}
}]\index{G@{G}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!G@{G}}\item[{\em 
G\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa2fe993340f6abb2234e543cd427df70b}
}]\index{Gsharp@{Gsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Gsharp@{Gsharp}}\item[{\em 
Gsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa2adbe5d79179fbb9103b944cd0f2d621}
}]\index{A@{A}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!A@{A}}\item[{\em 
A\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa42a4ade1acd55a49164099104990e09f}
}]\index{Asharp@{Asharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Asharp@{Asharp}}\item[{\em 
Asharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919faf6099e2a982664654807b32a8f11f197}
}]\index{B@{B}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!B@{B}}\item[{\em 
B\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa3f2a77ecd272aa6d6b5902faa5e5fc68}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00027 \{C, Csharp, D, Dsharp, E, F, Fsharp, G, Gsharp, A, Asharp, B\} tone;
\end{DoxyCode}


\subsubsection{Function Documentation}
\index{main.\+c@{main.\+c}!check\+Directory@{check\+Directory}}
\index{check\+Directory@{check\+Directory}!main.\+c@{main.\+c}}
\paragraph[{check\+Directory}]{\setlength{\rightskip}{0pt plus 5cm}void check\+Directory (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{M\+I\+D\+Ifile, }
\item[{D\+I\+R $\ast$}]{dir}
\end{DoxyParamCaption}
)}\label{main_8c_a15516ca0e878b486b04f9bd5d0b401d2}
A function to read music directory and prompt user to choose file 
\begin{DoxyParams}{Parameters}
{\em M\+I\+D\+Ifile} & a pointer to a string containing the name of the chosen input file \\
\hline
{\em dir} & a pointer to a directory \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00163                                              \{
00164   \textcolor{keyword}{struct }dirent *musicDir;
00165   \textcolor{keywordflow}{if} ((dir = opendir (\textcolor{stringliteral}{"./Music"})) != NULL) \{
00166     printf(\textcolor{stringliteral}{"Mulige numre\(\backslash\)n"});
00167       \textcolor{keywordflow}{while} ((musicDir = readdir (dir)) != NULL) \{
00168         printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, musicDir->d\_name);
00169       \}
00170   \} 
00171   \textcolor{keywordflow}{else} \{
00172     perror (\textcolor{stringliteral}{"Failure while opening directory"});
00173     exit (EXIT\_FAILURE);
00174   \}
00175   printf(\textcolor{stringliteral}{"Indtast det valgte nummer\(\backslash\)n"});
00176   scanf(\textcolor{stringliteral}{"%s"}, MIDIfile);
00177   chdir(\textcolor{stringliteral}{"./Music"});
00178 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!check\+Next\+Event@{check\+Next\+Event}}
\index{check\+Next\+Event@{check\+Next\+Event}!main.\+c@{main.\+c}}
\paragraph[{check\+Next\+Event}]{\setlength{\rightskip}{0pt plus 5cm}int check\+Next\+Event (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int}]{j}
\end{DoxyParamCaption}
)}\label{main_8c_a31a2c1016f54d5c2508c8a1578437f2d}

\begin{DoxyCode}
00264                                     \{
00265   \textcolor{keywordflow}{switch} (hex[j])\{
00266     \textcolor{keywordflow}{case} 0x90:
00267     \textcolor{keywordflow}{case} 0x80:
00268     \textcolor{keywordflow}{case} 0xA0:
00269     \textcolor{keywordflow}{case} 0xB0:
00270     \textcolor{keywordflow}{case} 0xC0:
00271     \textcolor{keywordflow}{case} 0xD0:
00272     \textcolor{keywordflow}{case} 0xE0: \textcolor{keywordflow}{return} 1; \textcolor{keywordflow}{break};
00273     \textcolor{keywordflow}{default}  : \textcolor{keywordflow}{return} 0; \textcolor{keywordflow}{break};
00274   \}
00275 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!check\+Scale@{check\+Scale}}
\index{check\+Scale@{check\+Scale}!main.\+c@{main.\+c}}
\paragraph[{check\+Scale}]{\setlength{\rightskip}{0pt plus 5cm}void check\+Scale (
\begin{DoxyParamCaption}
\item[{int}]{scales[$\,$], }
\item[{int}]{tone, }
\item[{int}]{key}
\end{DoxyParamCaption}
)}\label{main_8c_a14c87dc75ccb31a96d21ed5ca8edcb7e}
Checks if the tone given is within the scale of the key given. 
\begin{DoxyParams}{Parameters}
{\em scales} & An array containing the scalas \\
\hline
{\em tone} & An integer representing the tone to be checked \\
\hline
{\em key} & Integer representing the key the note is compared to \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00518                                                 \{
00519   \textcolor{keywordflow}{if}(tone < key)
00520     tone += 12;
00521   scales[key] = isInMajor(tone - key);
00522 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Notes@{count\+Notes}}
\index{count\+Notes@{count\+Notes}!main.\+c@{main.\+c}}
\paragraph[{count\+Notes}]{\setlength{\rightskip}{0pt plus 5cm}int count\+Notes (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int}]{amount}
\end{DoxyParamCaption}
)}\label{main_8c_a53151dcc1b6757799ff4fd28f192c9b9}
A function to count the number of notes in the entire song 
\begin{DoxyParams}{Parameters}
{\em hex\mbox{[}$\,$\mbox{]}} & an array with the stored information from the file \\
\hline
{\em amount} & an integer holding the total number of characters in the array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00198                                      \{
00199   \textcolor{keywordtype}{int} i = 0, res = 0;
00200   \textcolor{keywordflow}{for}(i = 0; i < amount; i++)\{
00201     \textcolor{keywordflow}{if}(hex[i] == 0x90)\{
00202       res++;
00203     \}
00204   \}
00205   \textcolor{keywordflow}{return} res;
00206 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Ticks1@{count\+Ticks1}}
\index{count\+Ticks1@{count\+Ticks1}!main.\+c@{main.\+c}}
\paragraph[{count\+Ticks1}]{\setlength{\rightskip}{0pt plus 5cm}void count\+Ticks1 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{i, }
\item[{int}]{delta\+Counter, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{tick\+Counter}
\end{DoxyParamCaption}
)}\label{main_8c_a80353c276d3da0964345cf6859959b3d}

\begin{DoxyCode}
00309                                                                                       \{
00310   noteAr[*tickCounter].ticks = 0;
00311   \textcolor{keywordtype}{int} tick = 0;
00312   \textcolor{keywordflow}{while}(deltaCounter < 7 && hex[(*i + deltaCounter)] > 0x80)
00313     tick += ((hex[(*i + deltaCounter++)] - 0x80) * 128);
00314   tick += hex[(*i + deltaCounter)];
00315   noteAr[*tickCounter].ticks += tick;
00316   *tickCounter += 1;
00317   *i += deltaCounter;
00318 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Ticks2@{count\+Ticks2}}
\index{count\+Ticks2@{count\+Ticks2}!main.\+c@{main.\+c}}
\paragraph[{count\+Ticks2}]{\setlength{\rightskip}{0pt plus 5cm}void count\+Ticks2 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{i, }
\item[{int}]{delta\+Counter, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{tick\+Counter}
\end{DoxyParamCaption}
)}\label{main_8c_a7ebf2e1e8ca3a04c4674d87e6fc0857a}

\begin{DoxyCode}
00320                                                                                       \{
00321   noteAr[*tickCounter].ticks = 0;
00322   \textcolor{keywordtype}{int} tick = 0;
00323   \textcolor{keywordflow}{while}(deltaCounter < 6 && hex[(*i + deltaCounter)] > 0x80)
00324     tick += ((hex[(*i + deltaCounter++)] - 0x80) * 128);
00325   tick += hex[(*i + deltaCounter)];
00326   noteAr[*tickCounter].ticks += tick;
00327   *tickCounter += 1;
00328   *i += deltaCounter;
00329 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!delta\+Time\+To\+Note\+Length@{delta\+Time\+To\+Note\+Length}}
\index{delta\+Time\+To\+Note\+Length@{delta\+Time\+To\+Note\+Length}!main.\+c@{main.\+c}}
\paragraph[{delta\+Time\+To\+Note\+Length}]{\setlength{\rightskip}{0pt plus 5cm}void delta\+Time\+To\+Note\+Length (
\begin{DoxyParamCaption}
\item[{int}]{ppqn, }
\item[{int}]{size, }
\item[{{\bf note} $\ast$}]{note\+Ar}
\end{DoxyParamCaption}
)}\label{main_8c_a10a435d76f1a94874a78c20c78f5d5c6}

\begin{DoxyCode}
00482                                                              \{
00483 
00484   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++)\{
00485   
00486     \textcolor{keywordtype}{double} noteLength = ((double) (noteAr[i].ticks)) / ((\textcolor{keywordtype}{double}) (ppqn/8));
00487 
00488     \textcolor{keywordflow}{if} (noteLength < 1.5 && noteLength >= 0)
00489       noteLength = 1;
00490     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 3 && noteLength >= 1.5)
00491       noteLength = 2;
00492     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 6 && noteLength >= 3)
00493       noteLength = 4;
00494     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 12 && noteLength >= 6)
00495       noteLength = 8;
00496     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 24 && noteLength >= 12)
00497       noteLength = 16;
00498     \textcolor{keywordflow}{else}
00499       noteLength = 32;
00500     
00501         noteAr[i].length = noteLength;
00502     \}
00503 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!fill\+Note@{fill\+Note}}
\index{fill\+Note@{fill\+Note}!main.\+c@{main.\+c}}
\paragraph[{fill\+Note}]{\setlength{\rightskip}{0pt plus 5cm}void fill\+Note (
\begin{DoxyParamCaption}
\item[{int}]{input\+Tone, }
\item[{{\bf note} $\ast$}]{note}
\end{DoxyParamCaption}
)}\label{main_8c_ad88978d32a0f080f58ed31ffe9c51396}
A function to fill out each of the structures of type note 
\begin{DoxyParams}{Parameters}
{\em input\+Tone} & the value of the hexadecimal collected on the \char`\"{}tone\char`\"{}-\/spot \\
\hline
{\em note$\ast$} & a pointer to a note-\/structure \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00335                                         \{
00336   note->tone = inputTone % 12;
00337   note->average = inputTone;
00338   note->octave = inputTone / 12;
00339 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!fill\+Song\+Data@{fill\+Song\+Data}}
\index{fill\+Song\+Data@{fill\+Song\+Data}!main.\+c@{main.\+c}}
\paragraph[{fill\+Song\+Data}]{\setlength{\rightskip}{0pt plus 5cm}void fill\+Song\+Data (
\begin{DoxyParamCaption}
\item[{{\bf data} $\ast$}]{data, }
\item[{int}]{hex[$\,$], }
\item[{int}]{numbers\+In\+Text}
\end{DoxyParamCaption}
)}\label{main_8c_a6406eca72b9402b7240ed0e453e8db46}
! A function, that fills out the song data 
\begin{DoxyParams}{Parameters}
{\em $\ast$data} & a pointer to a structure containing the tempo and mode of the song \\
\hline
{\em hex\mbox{[}$\,$\mbox{]}} & the array of integers read from the file \\
\hline
{\em numbers\+In\+Text} & the total amount of integers in the array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00214                                                            \{
00215   \textcolor{keywordtype}{int} j;
00216   \textcolor{comment}{/*Find the mode of the song, initialised as minor atm*/}
00217   \textcolor{keywordflow}{for}(j = 0; j < numbersInText; j++)\{
00218     \textcolor{comment}{/* finds the tempo */}
00219     \textcolor{keywordflow}{if}(hex[j] == 0xff && hex[j+1] == 0x51 && hex[j+2] == 0x03)\{
00220       data->tempo =  60000000/((hex[j+3] << 16) | (hex[j+4] << 8) | (hex[j+5]));
00221     \}
00222   \}
00223 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Events@{find\+Events}}
\index{find\+Events@{find\+Events}!main.\+c@{main.\+c}}
\paragraph[{find\+Events}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Events (
\begin{DoxyParamCaption}
\item[{int}]{numbers\+In\+Text, }
\item[{int}]{hex[$\,$], }
\item[{{\bf event\+Placement}}]{placement[$\,$], }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_a26401187db7de41990bd724524381f7a}

\begin{DoxyCode}
00225                                                                                                    \{
00226   \textcolor{keywordtype}{int} noteOff = 0, noteOn = 0, afterTouch = 0, controlChange = 0,
00227       programChange = 0, channelPressure = 0, pitchWheel = 0, n = 0, notes[numbersInText];
00228 
00229   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < numbersInText; j++)\{
00230     \textcolor{keywordflow}{switch} (hex[j])\{
00231       \textcolor{keywordflow}{case} 0x90: insertPlacement1(hex, &placement[noteOn++].noteOn, j, noteAr, &n, notes);               \textcolor{keywordflow}{
      break};
00232       \textcolor{keywordflow}{case} 0x80: insertPlacement1(hex, &placement[noteOff++].noteOff, j, noteAr, &n, notes);             \textcolor{keywordflow}{
      break};
00233       \textcolor{keywordflow}{case} 0xA0: insertPlacement1(hex, &placement[afterTouch++].afterTouch, j, noteAr, &n, notes);       \textcolor{keywordflow}{
      break};
00234       \textcolor{keywordflow}{case} 0xB0: insertPlacement1(hex, &placement[controlChange++].controlChange, j, noteAr, &n, notes); \textcolor{keywordflow}{
      break};
00235       \textcolor{keywordflow}{case} 0xC0: insertPlacement2(hex, &placement[programChange++].programChange, j);                    \textcolor{keywordflow}{
      break};
00236       \textcolor{keywordflow}{case} 0xD0: insertPlacement2(hex, &placement[channelPressure++].channelPressure, j);                \textcolor{keywordflow}{
      break};
00237       \textcolor{keywordflow}{case} 0xE0: insertPlacement1(hex, &placement[pitchWheel++].pitchWheel, j, noteAr, &n, notes);       \textcolor{keywordflow}{
      break};
00238       \textcolor{keywordflow}{default}  :                                                                                         \textcolor{keywordflow}{
      break};
00239     \}
00240   \}
00241   findTicks(numbersInText, hex, placement, noteAr, noteOn, size, notes);
00242 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Mode@{find\+Mode}}
\index{find\+Mode@{find\+Mode}!main.\+c@{main.\+c}}
\paragraph[{find\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf note} $\ast$}]{, }
\item[{int}]{, }
\item[{{\bf data} $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_a16182e7956158cfcf78a8b97423ee1da}
\index{main.\+c@{main.\+c}!find\+Mode@{find\+Mode}}
\index{find\+Mode@{find\+Mode}!main.\+c@{main.\+c}}
\paragraph[{find\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int}]{total\+Notes, }
\item[{{\bf data} $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{main_8c_a660cd7ea9eae225a44ccb0fd609984a3}
A function to find the mode of the song by first calculating the tone span over sets of notes in the song, and then comparing it to the definition of minor and major keys. 
\begin{DoxyParams}{Parameters}
{\em note\+Ar} & An array of all the notes in the entire song \\
\hline
{\em total\+Notes} & The number of notes in the song \\
\hline
{\em data} & The song data \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00529                                                         \{
00530   \textcolor{keywordtype}{int} majors[12] = \{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\}, minors[12] = \{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\};
00531   \textcolor{keywordtype}{int} x = 0, y = 0, z = 0, bar[4], sizeBar = 4, tempSpan = 999, span = 999, keynote = 0, 
      mode = 0, tempNote = 0;
00532 
00533   \textcolor{keywordflow}{for}(x = 0; x < totalNotes; x++)\{
00534     tempNote = noteAr[x].tone;
00535  
00536     \textcolor{keywordflow}{for}(y = C; y <= B; y++)\{
00537       \textcolor{keywordflow}{if}(majors[y])
00538         checkScale(majors, tempNote, y);
00539     \}
00540   \}
00541 
00542   \textcolor{keywordflow}{for}(y = 0; y < 12; y++)\{
00543     z = y;
00544     \textcolor{keywordflow}{if}(majors[z])\{
00545       \textcolor{keywordflow}{if}((z - 3) < 0)
00546         z += 12;
00547     minors[z-3] = 1;
00548     \}
00549   \}
00550 
00551   z = 0;  x = 0;
00552 
00553   \textcolor{comment}{/*Goes through all notes of the song and puts them into an array, 4 at a time*/}
00554   \textcolor{keywordflow}{while}(x < totalNotes)\{
00555     z = x;
00556     \textcolor{keywordflow}{for}(y = 0; y < sizeBar; y++, z++)\{
00557       \textcolor{keywordflow}{if}(z < totalNotes)
00558         bar[y] = noteAr[z].tone;
00559       \textcolor{keywordflow}{else}
00560         sizeBar = y;
00561     \}
00562 
00563     \textcolor{keywordflow}{if}(y == sizeBar)\{
00564       span = 999;
00565       \textcolor{comment}{/*Sort notes in ascending order*/}
00566       qsort(bar, sizeBar, \textcolor{keyword}{sizeof}(tone), sortTones);
00567 
00568       \textcolor{comment}{/*Finds the lowest possible tonespan over the array of 4 notes*/}
00569       \textcolor{keywordflow}{for}(z = 0; z < sizeBar; z++)\{
00570     \textcolor{keywordflow}{if}((z + 1) > 3)
00571           tempSpan = (bar[(z+1)%4]+12)-bar[z] + bar[(z+2)%4]-bar[(z+1)%4] + bar[(z+3)%4]-bar[(z+2)%4];
00572         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((z + 2) > 3)
00573           tempSpan = bar[(z+1)]-bar[z] + (bar[(z+2)%4]+12)-bar[(z+1)%4] + bar[(z+3)%4]-bar[(z+2)%4];
00574     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((z +3) > 3)
00575           tempSpan = bar[(z+1)]-bar[z] + bar[(z+2)]-bar[(z+1)] + (bar[(z+3)%4]+12)-bar[z];
00576     \textcolor{keywordflow}{else}
00577           tempSpan = bar[(z+1)]-bar[z] + bar[(z+2)]-bar[(z+1)] + bar[(z+3)]-bar[(z+2)];
00578         
00579     \textcolor{keywordflow}{if}(tempSpan < span && (majors[bar[z]] || minors[bar[z]]))\{
00580           span = tempSpan;
00581           keynote = bar[z];
00582         \}
00583       \}
00584       mode += isInScale(keynote, bar, sizeBar);
00585       x++;
00586     \}
00587   \}
00588   \textcolor{comment}{/*outputs result directly to the data struct*/}
00589   \textcolor{keywordflow}{if}(mode > 0)
00590     data->mode = major;
00591   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode < 0)
00592     data->mode = minor;
00593 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!Find\+Mood\+Amount@{Find\+Mood\+Amount}}
\index{Find\+Mood\+Amount@{Find\+Mood\+Amount}!main.\+c@{main.\+c}}
\paragraph[{Find\+Mood\+Amount}]{\setlength{\rightskip}{0pt plus 5cm}int Find\+Mood\+Amount (
\begin{DoxyParamCaption}
\item[{F\+I\+L\+E $\ast$}]{moods}
\end{DoxyParamCaption}
)}\label{main_8c_aea24927f2da3a892904ec1abd4ad01bf}

\begin{DoxyCode}
00654                                \{
00655   \textcolor{keywordtype}{int} i = 1;
00656   \textcolor{keywordflow}{while}(fgetc(moods) != EOF)\{
00657     \textcolor{keywordflow}{if}(fgetc(moods) == \textcolor{charliteral}{'\(\backslash\)n'})
00658       i++;
00659   \}
00660   rewind(moods);
00661   \textcolor{keywordflow}{return} i;
00662 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Note\+Length@{find\+Note\+Length}}
\index{find\+Note\+Length@{find\+Note\+Length}!main.\+c@{main.\+c}}
\paragraph[{find\+Note\+Length}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Note\+Length (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{int $\ast$}]{, }
\item[{int $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_ab56a62ec1c82722ba291a717b2afca5b}
\index{main.\+c@{main.\+c}!find\+Ticks@{find\+Ticks}}
\index{find\+Ticks@{find\+Ticks}!main.\+c@{main.\+c}}
\paragraph[{find\+Ticks}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Ticks (
\begin{DoxyParamCaption}
\item[{int}]{numbers\+In\+Text, }
\item[{int}]{hex[$\,$], }
\item[{{\bf event\+Placement}}]{placement[$\,$], }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int}]{note\+On, }
\item[{int $\ast$}]{size, }
\item[{int}]{notes[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_ae2c4173206817d367911d690f7958dac}

\begin{DoxyCode}
00277                                                                                                            
                      \{
00278   \textcolor{keywordtype}{int} tickCounter = 0, deltaCounter1 = 3, deltaCounter2 = 2;
00279   
00280   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < noteOn; j++)\{
00281     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = placement[j].noteOn; i < numbersInText; i++)\{
00282       \textcolor{keywordflow}{if}(hex[i] == 0x80)\{
00283         \textcolor{keywordflow}{if}(hex[i + 1] == notes[j])
00284           \textcolor{keywordflow}{break};
00285         \textcolor{keywordflow}{else}
00286           countTicks1(hex, &i, deltaCounter1, noteAr, &tickCounter);
00287       \}
00288       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xA0)\{
00289         \textcolor{keywordflow}{if}(hex[i + 1] == notes[j] && hex[i + 2] == 0x00)
00290           \textcolor{keywordflow}{break};
00291         \textcolor{keywordflow}{else}
00292           countTicks1(hex, &i, deltaCounter1, noteAr, &tickCounter);
00293       \}
00294       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xD0)\{
00295         \textcolor{keywordflow}{if}(hex[i + 1] == 0x00)
00296           \textcolor{keywordflow}{break};
00297         \textcolor{keywordflow}{else}
00298           countTicks2(hex, &i, deltaCounter2, noteAr, &tickCounter);
00299       \}
00300       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xC0)
00301         countTicks2(hex, &i, deltaCounter2, noteAr, &tickCounter);
00302       \textcolor{keywordflow}{else}
00303         countTicks1(hex, &i, deltaCounter1, noteAr, &tickCounter);   
00304     \}
00305   \}
00306   *size = tickCounter;
00307 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!get\+Hex@{get\+Hex}}
\index{get\+Hex@{get\+Hex}!main.\+c@{main.\+c}}
\paragraph[{get\+Hex}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Hex (
\begin{DoxyParamCaption}
\item[{F\+I\+L\+E $\ast$}]{f, }
\item[{int}]{hex\+Ar[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_a7e86822405cc3ff43db316d113a1fb6d}
A function, that retrieves the hexadecimals from the files and also returns the number of files 
\begin{DoxyParams}{Parameters}
{\em $\ast$f} & a pointer to the file the program is reading from \\
\hline
{\em hex\+Ar\mbox{[}$\,$\mbox{]}} & an array of integers, that the information is stored in \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00184                                 \{
00185   \textcolor{keywordtype}{int} i = 0, c;
00186   \textcolor{keywordflow}{while}( (c = fgetc(f)) != EOF && i < CHARS)\{
00187     hexAr[i] = c;
00188     i++;
00189   \}
00190   
00191   \textcolor{keywordflow}{return} i;
00192 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Moods@{insert\+Moods}}
\index{insert\+Moods@{insert\+Moods}!main.\+c@{main.\+c}}
\paragraph[{insert\+Moods}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Moods (
\begin{DoxyParamCaption}
\item[{{\bf mood\+Weighting}}]{mood\+Array[$\,$], }
\item[{F\+I\+L\+E $\ast$}]{moods}
\end{DoxyParamCaption}
)}\label{main_8c_a1709777308c32674291e7213d55feb6e}

\begin{DoxyCode}
00448                                                         \{
00449   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00450     fscanf(moods, \textcolor{stringliteral}{"%s %d %d %d %d"}, moodArray[i].name , &moodArray[i].mode, 
00451                                     &moodArray[i].tempo, &moodArray[i].toneLength,
00452                                     &moodArray[i].pitch);
00453   \}
00454 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Placement1@{insert\+Placement1}}
\index{insert\+Placement1@{insert\+Placement1}!main.\+c@{main.\+c}}
\paragraph[{insert\+Placement1}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Placement1 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{place, }
\item[{int}]{j, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{n, }
\item[{int}]{notes[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_a808a93f8aea71587a0bbb1ae766acd57}

\begin{DoxyCode}
00244                                                                                        \{
00245   \textcolor{keywordtype}{int} i = 3;
00246   \textcolor{keywordflow}{while}(i < 7 && hex[(j + i++)] > 0x80);
00247   \textcolor{keywordflow}{if}(checkNextEvent(hex, (j + i)))\{
00248     *place = j;
00249     \textcolor{keywordflow}{if}(hex[j] == 0x90)\{
00250       notes[*n] = hex[j + 1];
00251       fillNote(hex[j + 1], &noteAr[*n]);
00252       *n += 1;
00253     \}   
00254   \} 
00255 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Placement2@{insert\+Placement2}}
\index{insert\+Placement2@{insert\+Placement2}!main.\+c@{main.\+c}}
\paragraph[{insert\+Placement2}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Placement2 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{place, }
\item[{int}]{j}
\end{DoxyParamCaption}
)}\label{main_8c_a0349131ee04fd791a9bcd1205db44778}

\begin{DoxyCode}
00257                                                    \{
00258   \textcolor{keywordtype}{int} i = 2;
00259   \textcolor{keywordflow}{while}(i < 6 && hex[(j + i++)] > 0x80);
00260   \textcolor{keywordflow}{if}(checkNextEvent(hex, (j + i)))
00261     *place = j;
00262 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Major@{is\+In\+Major}}
\index{is\+In\+Major@{is\+In\+Major}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Major}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Major (
\begin{DoxyParamCaption}
\item[{int}]{tone\+Leap}
\end{DoxyParamCaption}
)}\label{main_8c_a241d0a265bf9c508dee8671ecab5f1d8}
A function to check if the given tone leap is in the major scale. 
\begin{DoxyParams}{Parameters}
{\em tone\+Leap} & An integer describing the processed tone leap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean value, returns 1 if the tone leap is in the major scale, 0 if it's not. 
\end{DoxyReturn}

\begin{DoxyCode}
00643                            \{
00644   \textcolor{keywordtype}{int} major[] = \{0, 2, 4, 5, 7, 9, 11\};
00645 
00646   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < SCALESIZE; i++)\{
00647     \textcolor{keywordflow}{if}(toneLeap == major[i])
00648       \textcolor{keywordflow}{return} 1;
00649   \}
00650   \textcolor{keywordflow}{return} 0;
00651 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Minor@{is\+In\+Minor}}
\index{is\+In\+Minor@{is\+In\+Minor}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Minor}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Minor (
\begin{DoxyParamCaption}
\item[{int}]{tone\+Leap}
\end{DoxyParamCaption}
)}\label{main_8c_a7a1c0b6f906689e24cb60e1e5ff8bc76}
A function to check if the given tone leap is in the minor scale. 
\begin{DoxyParams}{Parameters}
{\em tone\+Leap} & An integer describing the processed tone leap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean value, returns 1 if the tone leap is in the minor scale, 0 if it's not. 
\end{DoxyReturn}

\begin{DoxyCode}
00629                            \{
00630   \textcolor{keywordtype}{int} minor[] = \{0, 2, 3, 5, 7, 8, 10\};
00631 
00632   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < SCALESIZE; i++)\{
00633     \textcolor{keywordflow}{if}(toneLeap == minor[i])
00634       \textcolor{keywordflow}{return} 1;
00635   \}
00636   \textcolor{keywordflow}{return} 0;
00637 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Scale@{is\+In\+Scale}}
\index{is\+In\+Scale@{is\+In\+Scale}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Scale}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Scale (
\begin{DoxyParamCaption}
\item[{int}]{keytone, }
\item[{int}]{other\+Tones[$\,$], }
\item[{int}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_ab07d21079009fe6f42cd1a95b5db3522}
A function to check if a given scale in given keytone corresponds with the tones in the rest of the song. 
\begin{DoxyParams}{Parameters}
{\em keytone} & The keytone of the processed scale \\
\hline
{\em other\+Tones} & An array of the rest of the tones, which the function compares to the keytone and mode \\
\hline
{\em size} & The number of tones in the other\+Tones array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean value, returns 1 if the mode is major, -\/1 if it's minor and 0, if wasn't possible to decide. 
\end{DoxyReturn}

\begin{DoxyCode}
00601                                                       \{
00602   \textcolor{keywordtype}{int} toneLeap, isMinor = 1, isMajor = 1;
00603 
00604   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++)\{
00605     \textcolor{keywordflow}{if}(otherTones[i] < keytone)
00606       otherTones[i] += 12;
00607       toneLeap = otherTones[i] - keytone;
00608 
00609       \textcolor{keywordflow}{if}(isMinor)
00610         isMinor = isInMinor(toneLeap);
00611       \textcolor{keywordflow}{if}(isMajor)
00612         isMajor = isInMajor(toneLeap);
00613     \}
00614 
00615     \textcolor{keywordflow}{if}(isMinor && isMajor)
00616       \textcolor{keywordflow}{return} 0;
00617     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(isMinor)
00618       \textcolor{keywordflow}{return} -1;
00619     \textcolor{keywordflow}{if}(isMajor)
00620       \textcolor{keywordflow}{return} 1;
00621 
00622     \textcolor{keywordflow}{return} 0;
00623 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!main@{main}}
\index{main@{main}!main.\+c@{main.\+c}}
\paragraph[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{const char $\ast$}]{argv[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_ac0f2228420376f4db7e1274f2b41667c}

\begin{DoxyCode}
00096                                       \{
00097   DIR *dir = 0;
00098   FILE *f;
00099   \textcolor{keywordtype}{char} MIDIfile[25];
00100   \textcolor{comment}{/*Variables*/}
00101   \textcolor{keywordtype}{int} numbersInText = 0, notes, size = 0, mode = 5, tempo = 5, toneLength = 5, pitch = 5;
00102   FILE* moods = fopen(\textcolor{stringliteral}{"moods.txt"}, \textcolor{stringliteral}{"r"});
00103   \textcolor{keywordflow}{if}(moods == NULL)\{
00104     perror(\textcolor{stringliteral}{"Error: moods missing "});
00105     exit(EXIT\_FAILURE);
00106   \}
00107   AMOUNT_OF_MOODS = FindMoodAmount(moods);
00108   moodWeighting moodArray[AMOUNT_OF_MOODS];
00109   data data = \{0, major, D\};
00110   \textcolor{keywordflow}{if} (argv[1] == NULL)\{
00111     checkDirectory(MIDIfile, dir);
00112     f = fopen(MIDIfile, \textcolor{stringliteral}{"r"});  
00113     \textcolor{keywordflow}{if}(f == NULL)\{
00114       perror(\textcolor{stringliteral}{"Error opening file"});
00115       exit(EXIT\_FAILURE);
00116     \}
00117   \}
00118   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(argv[1] != NULL)\{
00119     f = fopen(argv[1],\textcolor{stringliteral}{"r"});
00120     \textcolor{keywordflow}{if}(f == NULL)\{
00121       perror(\textcolor{stringliteral}{"Error opening file"});
00122       exit(EXIT\_FAILURE);
00123     \}
00124   \}
00125   closedir (dir); 
00126   \textcolor{keywordtype}{int} *hex = (\textcolor{keywordtype}{int} *) malloc(CHARS * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00127   \textcolor{keywordflow}{if}(hex == NULL)\{
00128     printf(\textcolor{stringliteral}{"Memory allocation failed, bye!"});
00129     exit(EXIT\_FAILURE);
00130   \}
00131   \textcolor{comment}{/*Reading the data from the file*/}
00132   numbersInText = getHex(f, hex);
00133   fillSongData(&data, hex, numbersInText);
00134   notes = countNotes(hex, numbersInText);
00135   note *noteAr = (note*) malloc(notes * \textcolor{keyword}{sizeof}(note));
00136   \textcolor{keywordflow}{if}(noteAr == NULL)\{
00137     printf(\textcolor{stringliteral}{"Memory allocation failed, bye!"});
00138     exit(EXIT\_FAILURE);
00139   \}
00140   eventPlacement placement[numbersInText];
00141   findEvents(numbersInText, hex, placement, noteAr, &size);
00142   deltaTimeToNoteLength(960, size, noteAr);
00143   insertMoods(moodArray, moods);
00144   findMode(noteAr, notes, &data);
00145   settingPoints(&mode, &tempo, &toneLength, &pitch, data, notes, noteAr, &size);
00146   printSongData(data);
00147   \textcolor{keywordtype}{int} result[AMOUNT_OF_MOODS];
00148   weightingMatrix(moodArray, mode, tempo, toneLength, pitch, result);
00149 
00150   \textcolor{comment}{/*Clean up and close*/}
00151   fclose(f);
00152   free(hex);
00153   free(noteAr);
00154 
00155   \textcolor{comment}{/* Print results */}
00156   printResults(mode, tempo, toneLength, pitch, moodArray, result);
00157 
00158   \textcolor{keywordflow}{return} 0;
00159 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!print\+Note@{print\+Note}}
\index{print\+Note@{print\+Note}!main.\+c@{main.\+c}}
\paragraph[{print\+Note}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Note (
\begin{DoxyParamCaption}
\item[{{\bf note}}]{note}
\end{DoxyParamCaption}
)}\label{main_8c_aa9c735ae880cee4e1272bcf387462c9a}
A function to print the note 
\begin{DoxyParams}{Parameters}
{\em note} & the note structure to be printed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00344                          \{
00345   printf(\textcolor{stringliteral}{"Tone: "});
00346 
00347   \textcolor{keywordflow}{switch} (note.tone)\{
00348     \textcolor{keywordflow}{case} C     : printf(\textcolor{stringliteral}{"C"}) ; \textcolor{keywordflow}{break};
00349     \textcolor{keywordflow}{case} Csharp: printf(\textcolor{stringliteral}{"C#"}); \textcolor{keywordflow}{break};
00350     \textcolor{keywordflow}{case} D     : printf(\textcolor{stringliteral}{"D"}) ; \textcolor{keywordflow}{break};
00351     \textcolor{keywordflow}{case} Dsharp: printf(\textcolor{stringliteral}{"D#"}); \textcolor{keywordflow}{break};
00352     \textcolor{keywordflow}{case} E     : printf(\textcolor{stringliteral}{"E"}) ; \textcolor{keywordflow}{break};
00353     \textcolor{keywordflow}{case} F     : printf(\textcolor{stringliteral}{"F"}) ; \textcolor{keywordflow}{break};
00354     \textcolor{keywordflow}{case} Fsharp: printf(\textcolor{stringliteral}{"F#"}); \textcolor{keywordflow}{break};
00355     \textcolor{keywordflow}{case} G     : printf(\textcolor{stringliteral}{"G"}) ; \textcolor{keywordflow}{break};
00356     \textcolor{keywordflow}{case} Gsharp: printf(\textcolor{stringliteral}{"G#"}); \textcolor{keywordflow}{break};
00357     \textcolor{keywordflow}{case} A     : printf(\textcolor{stringliteral}{"A"}) ; \textcolor{keywordflow}{break};
00358     \textcolor{keywordflow}{case} Asharp: printf(\textcolor{stringliteral}{"A#"}); \textcolor{keywordflow}{break};
00359     \textcolor{keywordflow}{case} B     : printf(\textcolor{stringliteral}{"B"}) ; \textcolor{keywordflow}{break};
00360     \textcolor{keywordflow}{default}    : printf(\textcolor{stringliteral}{"Undefined note"}); \textcolor{keywordflow}{break};
00361   \}
00362   printf(\textcolor{stringliteral}{", octave: %d\(\backslash\)n"}, note.octave);
00363 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!print\+Results@{print\+Results}}
\index{print\+Results@{print\+Results}!main.\+c@{main.\+c}}
\paragraph[{print\+Results}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Results (
\begin{DoxyParamCaption}
\item[{int}]{mode, }
\item[{int}]{tempo, }
\item[{int}]{tone\+Length, }
\item[{int}]{pitch, }
\item[{{\bf mood\+Weighting}}]{mood\+Array[$\,$], }
\item[{int}]{result[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_a0d3402124f4e247da358dfdf2a0f4294}

\begin{DoxyCode}
00664                                                                                                           \{
00665   printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n"});
00666   printf(\textcolor{stringliteral}{" Mode:"});
00667   \textcolor{keywordflow}{if}(mode < 0)
00668     printf(\textcolor{stringliteral}{"        %d\(\backslash\)n"}, mode);
00669   \textcolor{keywordflow}{else}
00670     printf(\textcolor{stringliteral}{"         %d\(\backslash\)n"}, mode);
00671   printf(\textcolor{stringliteral}{" Tempo:"});
00672   \textcolor{keywordflow}{if}(tempo < 0)
00673     printf(\textcolor{stringliteral}{"       %d\(\backslash\)n"}, tempo);
00674   \textcolor{keywordflow}{else}
00675     printf(\textcolor{stringliteral}{"        %d\(\backslash\)n"}, tempo);
00676   printf(\textcolor{stringliteral}{" Tone length:"});
00677   \textcolor{keywordflow}{if}(toneLength < 0)
00678     printf(\textcolor{stringliteral}{" %d\(\backslash\)n"}, toneLength);
00679   \textcolor{keywordflow}{else}
00680     printf(\textcolor{stringliteral}{"  %d\(\backslash\)n"}, toneLength);
00681   printf(\textcolor{stringliteral}{" Pitch:"});
00682   \textcolor{keywordflow}{if}(pitch < 0)
00683     printf(\textcolor{stringliteral}{"       %d\(\backslash\)n"}, pitch);
00684   \textcolor{keywordflow}{else}
00685     printf(\textcolor{stringliteral}{"        %d\(\backslash\)n"}, pitch);
00686   printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n                                       WEIGHTINGS            \(\backslash\)n"});
00687   printf(\textcolor{stringliteral}{"                           Mode | Tempo | Tone length | Pitch\(\backslash\)n"});
00688   
00689   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00690     printf(\textcolor{stringliteral}{" %s"}, moodArray[i].name);
00691     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = strlen(moodArray[i].name); j < 26; j++)
00692       printf(\textcolor{stringliteral}{" "});
00693     \textcolor{keywordflow}{if}(moodArray[i].mode > -1)
00694       printf(\textcolor{stringliteral}{" "});
00695     printf(\textcolor{stringliteral}{" %d"}, moodArray[i].mode);
00696     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < 2; j++)
00697       printf(\textcolor{stringliteral}{" "});
00698     printf(\textcolor{stringliteral}{"| "});
00699     \textcolor{keywordflow}{if}(moodArray[i].tempo > -1)
00700       printf(\textcolor{stringliteral}{" "});
00701     printf(\textcolor{stringliteral}{" %d"}, moodArray[i].tempo);
00702     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < 3; j++)
00703       printf(\textcolor{stringliteral}{" "});
00704     printf(\textcolor{stringliteral}{"|    "});
00705     \textcolor{keywordflow}{if}(moodArray[i].toneLength > -1)
00706       printf(\textcolor{stringliteral}{" "});
00707     printf(\textcolor{stringliteral}{" %d"}, moodArray[i].toneLength);
00708     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < 6; j++)
00709       printf(\textcolor{stringliteral}{" "});
00710     printf(\textcolor{stringliteral}{"|  "});
00711     \textcolor{keywordflow}{if}(moodArray[i].pitch > -1)
00712       printf(\textcolor{stringliteral}{" "});
00713     printf(\textcolor{stringliteral}{" %d\(\backslash\)n"}, moodArray[i].pitch);
00714   \}
00715   printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n"});
00716 
00717   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00718     \textcolor{keywordflow}{if}(mode < 0)
00719       printf(\textcolor{stringliteral}{" %d * "}, mode);
00720     \textcolor{keywordflow}{else}
00721       printf(\textcolor{stringliteral}{" %d * "}, mode);
00722     \textcolor{keywordflow}{if}(moodArray[i].mode < 0)
00723       printf(\textcolor{stringliteral}{"%d + "}, moodArray[i].mode);
00724     \textcolor{keywordflow}{else}
00725       printf(\textcolor{stringliteral}{" %d + "}, moodArray[i].mode);
00726     \textcolor{keywordflow}{if}(tempo < 0)
00727       printf(\textcolor{stringliteral}{"%d * "}, tempo);
00728     \textcolor{keywordflow}{else}
00729       printf(\textcolor{stringliteral}{" %d * "}, tempo);
00730     \textcolor{keywordflow}{if}(moodArray[i].tempo < 0)
00731       printf(\textcolor{stringliteral}{"%d + "}, moodArray[i].tempo);
00732     \textcolor{keywordflow}{else}
00733       printf(\textcolor{stringliteral}{" %d + "}, moodArray[i].tempo);
00734     \textcolor{keywordflow}{if}(toneLength < 0)
00735       printf(\textcolor{stringliteral}{"%d * "}, toneLength);
00736     \textcolor{keywordflow}{else}
00737       printf(\textcolor{stringliteral}{" %d * "}, toneLength);
00738     \textcolor{keywordflow}{if}(moodArray[i].toneLength < 0)
00739       printf(\textcolor{stringliteral}{"%d + "}, moodArray[i].toneLength);
00740     \textcolor{keywordflow}{else}
00741       printf(\textcolor{stringliteral}{" %d + "}, moodArray[i].toneLength);
00742     \textcolor{keywordflow}{if}(pitch < 0)
00743       printf(\textcolor{stringliteral}{"%d * "}, pitch);
00744     \textcolor{keywordflow}{else}
00745       printf(\textcolor{stringliteral}{" %d * "}, pitch);
00746     \textcolor{keywordflow}{if}(moodArray[i].pitch < 0)
00747       printf(\textcolor{stringliteral}{"%d = "}, moodArray[i].pitch);
00748     \textcolor{keywordflow}{else}
00749       printf(\textcolor{stringliteral}{" %d = "}, moodArray[i].pitch);
00750     \textcolor{keywordflow}{if}(result[i] < 0)
00751       printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result[i]);
00752     \textcolor{keywordflow}{else}
00753       printf(\textcolor{stringliteral}{" %d\(\backslash\)n"}, result[i]);
00754   \}
00755   \textcolor{keywordtype}{int} moodOfMelodi = 0;
00756   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00757     \textcolor{keywordflow}{if}(moodOfMelodi < result[i])
00758       moodOfMelodi = i;
00759   \}
00760   \textcolor{keywordtype}{int} test = 0;
00761   
00762   \textcolor{keywordflow}{if}(!strcmp(moodArray[moodOfMelodi].name, \textcolor{stringliteral}{"Happy"}))\{
00763     printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n Sad "});
00764     \textcolor{keywordflow}{while}(test < 51)\{
00765       \textcolor{keywordflow}{if}(test == 25)
00766         printf(\textcolor{stringliteral}{"|"});
00767       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(test == (((result[moodOfMelodi] + 100) / 4)))
00768         printf(\textcolor{stringliteral}{"["});
00769       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(test == (((result[moodOfMelodi] + 100) / 4) + 2))
00770         printf(\textcolor{stringliteral}{"]"});
00771       \textcolor{keywordflow}{else}
00772         printf(\textcolor{stringliteral}{"-"});
00773       test++;
00774     \}
00775     printf(\textcolor{stringliteral}{" Happy\(\backslash\)n\(\backslash\)n\(\backslash\)n"});
00776   \}
00777   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(!strcmp(moodArray[moodOfMelodi].name, \textcolor{stringliteral}{"Sad"}))\{
00778     printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)n Sad "});
00779     \textcolor{keywordflow}{while}(test < 51)\{
00780       \textcolor{keywordflow}{if}(test == 25)
00781         printf(\textcolor{stringliteral}{"|"});
00782       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(test == (((-(result[moodOfMelodi]) + 100) / 4)))
00783         printf(\textcolor{stringliteral}{"["});
00784       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(test == (((-(result[moodOfMelodi]) + 100) / 4) + 2))
00785         printf(\textcolor{stringliteral}{"]"});
00786       \textcolor{keywordflow}{else}
00787         printf(\textcolor{stringliteral}{"-"});
00788       test++;
00789     \}
00790     printf(\textcolor{stringliteral}{" Happy\(\backslash\)n\(\backslash\)n\(\backslash\)n"});
00791   \}
00792 
00793   printf(\textcolor{stringliteral}{"\(\backslash\)n The mood of the melodi is %s\(\backslash\)n"}, moodArray[moodOfMelodi].name);
00794 \}\end{DoxyCode}
\index{main.\+c@{main.\+c}!print\+Song\+Data@{print\+Song\+Data}}
\index{print\+Song\+Data@{print\+Song\+Data}!main.\+c@{main.\+c}}
\paragraph[{print\+Song\+Data}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Song\+Data (
\begin{DoxyParamCaption}
\item[{{\bf data}}]{data}
\end{DoxyParamCaption}
)}\label{main_8c_a96686ff783072b26aa8666d0281d053c}
A function to print out the overall data of the song, tempo and mode 
\begin{DoxyParams}{Parameters}
{\em data} & the data to be printed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00368                              \{
00369   printf(\textcolor{stringliteral}{"Tempo: %d\(\backslash\)nMode: "}, data.tempo);
00370   \textcolor{keywordflow}{switch}(data.mode)\{
00371     \textcolor{keywordflow}{case} minor: printf(\textcolor{stringliteral}{"minor"}); \textcolor{keywordflow}{break};
00372     \textcolor{keywordflow}{case} major: printf(\textcolor{stringliteral}{"major"}); \textcolor{keywordflow}{break};
00373     \textcolor{keywordflow}{default}: printf(\textcolor{stringliteral}{"unknown mode"}); \textcolor{keywordflow}{break};
00374   \}
00375   printf(\textcolor{stringliteral}{"\(\backslash\)nKeytone: %d"}, data.key);
00376   putchar(\textcolor{charliteral}{'\(\backslash\)n'});
00377 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!setting\+Points@{setting\+Points}}
\index{setting\+Points@{setting\+Points}!main.\+c@{main.\+c}}
\paragraph[{setting\+Points}]{\setlength{\rightskip}{0pt plus 5cm}void setting\+Points (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{mode, }
\item[{int $\ast$}]{tempo, }
\item[{int $\ast$}]{length, }
\item[{int $\ast$}]{octave, }
\item[{{\bf data}}]{data, }
\item[{int}]{notes, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_ac5cf65542ee2eded456a070d2159af90}

\begin{DoxyCode}
00379                                                                                                            
              \{
00380   \textcolor{keywordtype}{int} deltaTime = 2, combined = 0, averageNote = 0;
00381   \textcolor{keywordflow}{switch}(data.mode)\{
00382     \textcolor{keywordflow}{case} minor: *mode = -5; \textcolor{keywordflow}{break};
00383     \textcolor{keywordflow}{case} major: *mode = 5; \textcolor{keywordflow}{break};
00384     \textcolor{keywordflow}{default}: *mode = 0; \textcolor{keywordflow}{break};
00385   \}
00386   \textcolor{keywordflow}{if}(data.tempo < 60)
00387     *tempo = -5;
00388   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 60 && data.tempo < 70)
00389     *tempo = -4;
00390   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 70 && data.tempo < 80)
00391     *tempo = -3;  
00392   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 80 && data.tempo < 90)
00393     *tempo = -2;
00394   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 90 && data.tempo < 100)
00395     *tempo = -1;
00396   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 100 && data.tempo < 120)
00397     *tempo =  0;  
00398   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 120 && data.tempo < 130)
00399     *tempo =  1;
00400   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 130 && data.tempo < 140)
00401     *tempo =  2;
00402   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 140 && data.tempo < 150)
00403     *tempo =  3;
00404   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 150 && data.tempo < 160)
00405     *tempo =  4;
00406   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >=  160)
00407     *tempo =  5;
00408 
00409   \textcolor{keywordflow}{switch}(deltaTime)\{
00410     \textcolor{keywordflow}{case} 1: *length = -5; \textcolor{keywordflow}{break};
00411     \textcolor{keywordflow}{case} 2: *length = -4; \textcolor{keywordflow}{break};
00412     \textcolor{keywordflow}{case} 4: *length = -2; \textcolor{keywordflow}{break};
00413     \textcolor{keywordflow}{case} 8: *length =  0; \textcolor{keywordflow}{break};
00414     \textcolor{keywordflow}{case} 16: *length = 3; \textcolor{keywordflow}{break};
00415     \textcolor{keywordflow}{case} 32: *length = 5; \textcolor{keywordflow}{break};
00416   \}
00417   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < notes; i++)\{
00418     combined += noteAr[i].average;
00419   \}
00420   averageNote = combined/notes;
00421 
00422   \textcolor{keywordflow}{if}(averageNote <= 16)
00423     *octave = -5;
00424   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 17 && averageNote <= 23)
00425     *octave = -4;
00426   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 24 && averageNote <= 30)
00427     *octave = -3;
00428   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 31 && averageNote <= 37)
00429     *octave = -2;
00430   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 38 && averageNote <= 44)
00431     *octave = -1;
00432   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 45 && averageNote <= 51)
00433     *octave = 0;
00434   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 52 && averageNote <= 58)
00435     *octave = 1;
00436   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 59 && averageNote <= 65)
00437     *octave = 2;
00438   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 66 && averageNote <= 72)
00439     *octave = 3;
00440   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 73 && averageNote <= 79)
00441     *octave = 4;
00442   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >=80)
00443     *octave = 5;
00444 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!sort\+Result@{sort\+Result}}
\index{sort\+Result@{sort\+Result}!main.\+c@{main.\+c}}
\paragraph[{sort\+Result}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Result (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{pa, }
\item[{const void $\ast$}]{pb}
\end{DoxyParamCaption}
)}\label{main_8c_ac6a3184d104e99d57824eecaabab8ed5}

\begin{DoxyCode}
00475                                               \{
00476   \textcolor{keywordtype}{int} a = *(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*)pa;
00477   \textcolor{keywordtype}{int} b = *(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*)pb;
00478   \textcolor{keywordflow}{return} (b-a);
00479 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!sort\+Toner@{sort\+Toner}}
\index{sort\+Toner@{sort\+Toner}!main.\+c@{main.\+c}}
\paragraph[{sort\+Toner}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Toner (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{, }
\item[{const void $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_a27beb09cf7217b8c5f3789913aa857db}
\index{main.\+c@{main.\+c}!sort\+Tones@{sort\+Tones}}
\index{sort\+Tones@{sort\+Tones}!main.\+c@{main.\+c}}
\paragraph[{sort\+Tones}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Tones (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}\label{main_8c_a33b74ebb6acaeb30576c9e66aebe2fb6}
A function to sort integers in ascending order, used by qsort 
\begin{DoxyCode}
00507                                            \{
00508   \textcolor{keywordtype}{int} *i1 = (\textcolor{keywordtype}{int}*) a, *i2 = (\textcolor{keywordtype}{int}*) b;
00509 
00510   \textcolor{keywordflow}{return} *i1 - *i2;
00511 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!weighting\+Matrix@{weighting\+Matrix}}
\index{weighting\+Matrix@{weighting\+Matrix}!main.\+c@{main.\+c}}
\paragraph[{weighting\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}void weighting\+Matrix (
\begin{DoxyParamCaption}
\item[{{\bf mood\+Weighting}}]{mood\+Array[$\,$], }
\item[{int}]{mode, }
\item[{int}]{tempo, }
\item[{int}]{tone\+Length, }
\item[{int}]{pitch, }
\item[{int $\ast$}]{result}
\end{DoxyParamCaption}
)}\label{main_8c_ade01440ee57aef2e5c1ec4f33678be51}

\begin{DoxyCode}
00457                                                                                                            
       \{
00458   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00459     result[i] = 0;
00460   \}
00461   
00462   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00463     result[i] += (moodArray[i].mode * mode);
00464     result[i] += (moodArray[i].tempo * tempo);
00465     result[i] += (moodArray[i].toneLength * toneLength);
00466     result[i] += (moodArray[i].pitch * pitch);
00467   \}
00468   
00469   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00470     printf(\textcolor{stringliteral}{"%s: %d\(\backslash\)n"}, moodArray[i].name, result[i]);
00471   \}
00472 \}
\end{DoxyCode}


\subsubsection{Variable Documentation}
\index{main.\+c@{main.\+c}!A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S@{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}}
\index{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S@{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}!main.\+c@{main.\+c}}
\paragraph[{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}]{\setlength{\rightskip}{0pt plus 5cm}int A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}\label{main_8c_ad4daca5a141533e7c95216763e28c4fe}
