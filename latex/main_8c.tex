\subsection{main.\+c File Reference}
\label{main_8c}\index{main.\+c@{main.\+c}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$dirent.\+h$>$}\\*
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct {\bf note}
\item 
struct {\bf data}
\item 
struct {\bf points}
\item 
struct {\bf mood\+Weighting}
\item 
struct {\bf event\+Placement}
\end{DoxyCompactItemize}
\subsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bf C\+H\+A\+R\+S}~1000
\item 
\#define {\bf S\+C\+A\+L\+E\+S\+I\+Z\+E}~7
\end{DoxyCompactItemize}
\subsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef enum {\bf mode} {\bf mode}
\item 
typedef enum {\bf tone} {\bf tone}
\item 
typedef enum {\bf mood} {\bf mood}
\end{DoxyCompactItemize}
\subsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf mode} \{ {\bf major}, 
{\bf minor}
 \}
\item 
enum {\bf tone} \{ \\*
{\bf C}, 
{\bf Csharp}, 
{\bf D}, 
{\bf Dsharp}, 
\\*
{\bf E}, 
{\bf F}, 
{\bf Fsharp}, 
{\bf G}, 
\\*
{\bf Gsharp}, 
{\bf A}, 
{\bf Asharp}, 
{\bf B}
 \}
\item 
enum {\bf mood} \{ {\bf glad}, 
{\bf sad}
 \}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf check\+Directory} (char $\ast$)
\item 
void {\bf find\+Note\+Length} (double x, int $\ast$, int $\ast$)
\item 
void {\bf print\+Note} ({\bf note})
\item 
int {\bf get\+Hex} (F\+I\+L\+E $\ast$, int[$\,$])
\item 
void {\bf fill\+Song\+Data} ({\bf data} $\ast$, int[$\,$], int)
\item 
int {\bf count\+Notes} (int[$\,$], int)
\item 
void {\bf fill\+Note} (int, {\bf note} $\ast$)
\item 
void {\bf print\+Song\+Data} ({\bf data})
\item 
void {\bf setting\+Points} (int $\ast$, int $\ast$, int $\ast$, int $\ast$, {\bf data}, int, {\bf note}[$\,$], int $\ast$)
\item 
void {\bf insert\+Moods} ({\bf mood\+Weighting}[$\,$], F\+I\+L\+E $\ast$)
\item 
int {\bf weighting\+Matrix} ({\bf mood\+Weighting}[$\,$], int, int, int, int)
\item 
void {\bf find\+Events} (int, int[$\,$], {\bf event\+Placement}[$\,$], {\bf note}[$\,$], int[$\,$], int $\ast$)
\item 
void {\bf insert\+Placement1} (int[$\,$], int $\ast$, int, {\bf note}[$\,$], int $\ast$)
\item 
void {\bf insert\+Placement2} (int[$\,$], int $\ast$, int)
\item 
int {\bf check\+Next\+Event} (int[$\,$], int)
\item 
void {\bf find\+Ticks} (int, int[$\,$], {\bf event\+Placement}[$\,$], {\bf note}[$\,$], int[$\,$], int, int $\ast$)
\item 
void {\bf count\+Ticks1} (int[$\,$], int $\ast$, int, int[$\,$], int $\ast$)
\item 
void {\bf count\+Ticks2} (int[$\,$], int $\ast$, int, int[$\,$], int $\ast$)
\item 
int {\bf sort\+Result} (const void $\ast$, const void $\ast$)
\item 
void {\bf delta\+Time\+To\+Note\+Length} (int $\ast$, int, int, {\bf note} $\ast$)
\item 
int {\bf is\+In\+Scale} (int, int[$\,$], int)
\item 
int {\bf is\+In\+Minor} (int)
\item 
int {\bf is\+In\+Major} (int)
\item 
int {\bf sort\+Toner} (const void $\ast$, const void $\ast$)
\item 
void {\bf find\+Mode} ({\bf note} $\ast$, int, {\bf data} $\ast$)
\item 
int {\bf Find\+Mood\+Amount} (F\+I\+L\+E $\ast$)
\item 
int {\bf main} (int argc, const char $\ast$argv[$\,$])
\item 
int {\bf sort\+Tones} (const void $\ast$a, const void $\ast$b)
\item 
void {\bf find\+Mode} ({\bf note} note\+Ar[$\,$], int total\+Notes, {\bf data} $\ast${\bf data})
\end{DoxyCompactItemize}
\subsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int {\bf A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}
\end{DoxyCompactItemize}


\subsubsection{Macro Definition Documentation}
\index{main.\+c@{main.\+c}!C\+H\+A\+R\+S@{C\+H\+A\+R\+S}}
\index{C\+H\+A\+R\+S@{C\+H\+A\+R\+S}!main.\+c@{main.\+c}}
\paragraph[{C\+H\+A\+R\+S}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+H\+A\+R\+S~1000}\label{main_8c_a5d7cfaaf3d71eb89b31364adb9fda6a6}
\index{main.\+c@{main.\+c}!S\+C\+A\+L\+E\+S\+I\+Z\+E@{S\+C\+A\+L\+E\+S\+I\+Z\+E}}
\index{S\+C\+A\+L\+E\+S\+I\+Z\+E@{S\+C\+A\+L\+E\+S\+I\+Z\+E}!main.\+c@{main.\+c}}
\paragraph[{S\+C\+A\+L\+E\+S\+I\+Z\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+C\+A\+L\+E\+S\+I\+Z\+E~7}\label{main_8c_a3c7b5c7d1b09d118aa63ec87e3c73a8b}


\subsubsection{Typedef Documentation}
\index{main.\+c@{main.\+c}!mode@{mode}}
\index{mode@{mode}!main.\+c@{main.\+c}}
\paragraph[{mode}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf mode}  {\bf mode}}\label{main_8c_abcec22444f1b2fc64f59764d40244d9f}
\index{main.\+c@{main.\+c}!mood@{mood}}
\index{mood@{mood}!main.\+c@{main.\+c}}
\paragraph[{mood}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf mood}  {\bf mood}}\label{main_8c_a3e304bbd72e3a576384c6e8cdb661eb4}
\index{main.\+c@{main.\+c}!tone@{tone}}
\index{tone@{tone}!main.\+c@{main.\+c}}
\paragraph[{tone}]{\setlength{\rightskip}{0pt plus 5cm}typedef enum {\bf tone}  {\bf tone}}\label{main_8c_aac01cecf1f254ffa121e2715527a6a5a}


\subsubsection{Enumeration Type Documentation}
\index{main.\+c@{main.\+c}!mode@{mode}}
\index{mode@{mode}!main.\+c@{main.\+c}}
\paragraph[{mode}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mode}}\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{major@{major}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!major@{major}}\item[{\em 
major\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167adc8c3476e4d3526d10210987c7131cb5}
}]\index{minor@{minor}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!minor@{minor}}\item[{\em 
minor\label{main_8c_a1a6b6fb557d8d37d59700faf4e4c9167a252026d6db6e81a42ef18bfd98b45a11}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00026 \{major, minor\} mode;
\end{DoxyCode}
\index{main.\+c@{main.\+c}!mood@{mood}}
\index{mood@{mood}!main.\+c@{main.\+c}}
\paragraph[{mood}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mood}}\label{main_8c_a845e01d4d631be8d8fac14b162607e7f}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{glad@{glad}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!glad@{glad}}\item[{\em 
glad\label{main_8c_a845e01d4d631be8d8fac14b162607e7fa55170d14edc722ae6672132bd212a19d}
}]\index{sad@{sad}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!sad@{sad}}\item[{\em 
sad\label{main_8c_a845e01d4d631be8d8fac14b162607e7fa545d9f58d50a21cb0f1a64155ec91a05}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00028 \{glad, sad\} mood;
\end{DoxyCode}
\index{main.\+c@{main.\+c}!tone@{tone}}
\index{tone@{tone}!main.\+c@{main.\+c}}
\paragraph[{tone}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tone}}\label{main_8c_aeb761eda34d47c3e64ca804875fd919f}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{C@{C}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!C@{C}}\item[{\em 
C\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa739ce3f516592d245d16fd8a3893472c}
}]\index{Csharp@{Csharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Csharp@{Csharp}}\item[{\em 
Csharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa443d44cb35267bc4445499d568e4bd26}
}]\index{D@{D}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!D@{D}}\item[{\em 
D\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa77a6b11f9898c052926f1d49765861e8}
}]\index{Dsharp@{Dsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Dsharp@{Dsharp}}\item[{\em 
Dsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fad3b2877ea9dc7d69bd1b52477a01a68b}
}]\index{E@{E}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!E@{E}}\item[{\em 
E\label{main_8c_aeb761eda34d47c3e64ca804875fd919fab199e021998d49b1f09338d8b9b18ecb}
}]\index{F@{F}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!F@{F}}\item[{\em 
F\label{main_8c_aeb761eda34d47c3e64ca804875fd919faf382a63cc3d6491bf26b59e66f46826d}
}]\index{Fsharp@{Fsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Fsharp@{Fsharp}}\item[{\em 
Fsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fad4ad1b6a094e98ff41e6e4f366769fc3}
}]\index{G@{G}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!G@{G}}\item[{\em 
G\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa2fe993340f6abb2234e543cd427df70b}
}]\index{Gsharp@{Gsharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Gsharp@{Gsharp}}\item[{\em 
Gsharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa2adbe5d79179fbb9103b944cd0f2d621}
}]\index{A@{A}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!A@{A}}\item[{\em 
A\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa42a4ade1acd55a49164099104990e09f}
}]\index{Asharp@{Asharp}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!Asharp@{Asharp}}\item[{\em 
Asharp\label{main_8c_aeb761eda34d47c3e64ca804875fd919faf6099e2a982664654807b32a8f11f197}
}]\index{B@{B}!main.\+c@{main.\+c}}\index{main.\+c@{main.\+c}!B@{B}}\item[{\em 
B\label{main_8c_aeb761eda34d47c3e64ca804875fd919fa3f2a77ecd272aa6d6b5902faa5e5fc68}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
00027 \{C, Csharp, D, Dsharp, E, F, Fsharp, G, Gsharp, A, Asharp, B\} tone;
\end{DoxyCode}


\subsubsection{Function Documentation}
\index{main.\+c@{main.\+c}!check\+Directory@{check\+Directory}}
\index{check\+Directory@{check\+Directory}!main.\+c@{main.\+c}}
\paragraph[{check\+Directory}]{\setlength{\rightskip}{0pt plus 5cm}void check\+Directory (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{M\+I\+D\+Ifile}
\end{DoxyParamCaption}
)}\label{main_8c_a6e65cd59478f60276ddf27b226f5ef8c}
A function to read music directory and prompt user to choose file 
\begin{DoxyParams}{Parameters}
{\em } & char$\ast$]\+: M\+I\+D\+Ifile\+: a pointer to a string containing the name of the chosen input file \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00162                                    \{
00163   DIR *dir;
00164   \textcolor{keyword}{struct }dirent *musicDir;
00165   \textcolor{keywordflow}{if} ((dir = opendir (\textcolor{stringliteral}{"./Music"})) != NULL) \{
00166     printf(\textcolor{stringliteral}{"Mulige numre\(\backslash\)n"});
00167     \textcolor{comment}{/* print all the files and directories within specified directory */}
00168       \textcolor{keywordflow}{while} ((musicDir = readdir (dir)) != NULL) \{
00169         printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, musicDir->d\_name);
00170       \}
00171     closedir (dir);
00172   \} 
00173   \textcolor{keywordflow}{else} \{
00174   \textcolor{comment}{/* Could not open directory */}
00175     perror (\textcolor{stringliteral}{"Failure while opening directory"});
00176     exit (EXIT\_FAILURE);
00177   \}
00178   printf(\textcolor{stringliteral}{"Indtast det valgte nummer\(\backslash\)n"});
00179   scanf(\textcolor{stringliteral}{"%s"}, MIDIfile);
00180 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!check\+Next\+Event@{check\+Next\+Event}}
\index{check\+Next\+Event@{check\+Next\+Event}!main.\+c@{main.\+c}}
\paragraph[{check\+Next\+Event}]{\setlength{\rightskip}{0pt plus 5cm}int check\+Next\+Event (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int}]{j}
\end{DoxyParamCaption}
)}\label{main_8c_a31a2c1016f54d5c2508c8a1578437f2d}

\begin{DoxyCode}
00265                                     \{
00266   \textcolor{keywordflow}{switch} (hex[j])\{
00267     \textcolor{keywordflow}{case} 0x90:
00268     \textcolor{keywordflow}{case} 0x80:
00269     \textcolor{keywordflow}{case} 0xA0:
00270     \textcolor{keywordflow}{case} 0xB0:
00271     \textcolor{keywordflow}{case} 0xC0:
00272     \textcolor{keywordflow}{case} 0xD0:
00273     \textcolor{keywordflow}{case} 0xE0: \textcolor{keywordflow}{return} 1; \textcolor{keywordflow}{break};
00274     \textcolor{keywordflow}{default}  : \textcolor{keywordflow}{return} 0; \textcolor{keywordflow}{break};
00275   \}
00276 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Notes@{count\+Notes}}
\index{count\+Notes@{count\+Notes}!main.\+c@{main.\+c}}
\paragraph[{count\+Notes}]{\setlength{\rightskip}{0pt plus 5cm}int count\+Notes (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int}]{amount}
\end{DoxyParamCaption}
)}\label{main_8c_a53151dcc1b6757799ff4fd28f192c9b9}
A function to count the number of notes in the entire song 
\begin{DoxyParams}{Parameters}
{\em } & int]\+: hex[]\+: an array with the stored information from the file \\
\hline
{\em } & int]\+: amount\+: an integer holding the total number of characters in the array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00200                                      \{
00201   \textcolor{keywordtype}{int} i = 0, res = 0;
00202   \textcolor{keywordflow}{for}(i = 0; i < amount; i++)\{
00203     \textcolor{keywordflow}{if}(hex[i] == 0x90)\{
00204       res++;
00205     \}
00206   \}
00207   \textcolor{keywordflow}{return} res;
00208 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Ticks1@{count\+Ticks1}}
\index{count\+Ticks1@{count\+Ticks1}!main.\+c@{main.\+c}}
\paragraph[{count\+Ticks1}]{\setlength{\rightskip}{0pt plus 5cm}void count\+Ticks1 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{i, }
\item[{int}]{delta\+Counter, }
\item[{int}]{ticks[$\,$], }
\item[{int $\ast$}]{tick\+Counter}
\end{DoxyParamCaption}
)}\label{main_8c_af836f26ac499b26de031f92ef5899a31}

\begin{DoxyCode}
00314                                                                                     \{
00315   \textcolor{keywordflow}{while}(deltaCounter < 7 && hex[(*i + deltaCounter)] > 0x80)
00316     ticks[*tickCounter] += ((hex[(*i + deltaCounter++)] - 0x80) * 128);
00317   ticks[*tickCounter++] += hex[(*i + deltaCounter++)];
00318   i += deltaCounter;
00319 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!count\+Ticks2@{count\+Ticks2}}
\index{count\+Ticks2@{count\+Ticks2}!main.\+c@{main.\+c}}
\paragraph[{count\+Ticks2}]{\setlength{\rightskip}{0pt plus 5cm}void count\+Ticks2 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{i, }
\item[{int}]{delta\+Counter, }
\item[{int}]{ticks[$\,$], }
\item[{int $\ast$}]{tick\+Counter}
\end{DoxyParamCaption}
)}\label{main_8c_a4bc2fa0c74fcabd55e06bd0d49e1f992}

\begin{DoxyCode}
00321                                                                                     \{
00322   \textcolor{keywordflow}{while}(deltaCounter < 6 && hex[(*i + deltaCounter)] > 0x80)
00323     ticks[*tickCounter] += ((hex[(*i + deltaCounter++)] - 0x80) * 128);
00324   ticks[*tickCounter++] += hex[(*i + deltaCounter++)];
00325   i += deltaCounter;
00326 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!delta\+Time\+To\+Note\+Length@{delta\+Time\+To\+Note\+Length}}
\index{delta\+Time\+To\+Note\+Length@{delta\+Time\+To\+Note\+Length}!main.\+c@{main.\+c}}
\paragraph[{delta\+Time\+To\+Note\+Length}]{\setlength{\rightskip}{0pt plus 5cm}void delta\+Time\+To\+Note\+Length (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{ticks, }
\item[{int}]{ppqn, }
\item[{int}]{size, }
\item[{{\bf note} $\ast$}]{note\+Ar}
\end{DoxyParamCaption}
)}\label{main_8c_a5ce54b23ee9b2c1ae92adac7a9505180}

\begin{DoxyCode}
00484                                                                          \{
00485 
00486   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++)\{
00487   
00488     \textcolor{keywordtype}{double} noteLength = ((double) (ticks[i])) / ((\textcolor{keywordtype}{double}) (ppqn/8));
00489 
00490     \textcolor{keywordflow}{if} (noteLength < 1.5 && noteLength >= 0)
00491       noteLength = 1;
00492     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 3 && noteLength >= 1.5)
00493       noteLength = 2;
00494     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 6 && noteLength >= 3)
00495       noteLength = 4;
00496     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 12 && noteLength >= 6)
00497       noteLength = 8;
00498     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (noteLength < 24 && noteLength >= 12)
00499       noteLength = 16;
00500     \textcolor{keywordflow}{else}
00501       noteLength = 32;
00502     
00503         noteAr[i].length = noteLength;
00504     \}
00505 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!fill\+Note@{fill\+Note}}
\index{fill\+Note@{fill\+Note}!main.\+c@{main.\+c}}
\paragraph[{fill\+Note}]{\setlength{\rightskip}{0pt plus 5cm}void fill\+Note (
\begin{DoxyParamCaption}
\item[{int}]{input\+Tone, }
\item[{{\bf note} $\ast$}]{note}
\end{DoxyParamCaption}
)}\label{main_8c_ad88978d32a0f080f58ed31ffe9c51396}
A function to fill out each of the structures of type note 
\begin{DoxyParams}{Parameters}
{\em } & int]\+: input\+Tone\+: the value of the hexadecimal collected on the \char`\"{}tone\char`\"{}-\/spot \\
\hline
{\em } & note$\ast$]\+: note\+: a pointer to a note-\/structure \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00332                                         \{
00333   note->tone = inputTone % 12;
00334   note->average = inputTone;
00335   note->octave = inputTone / 12;
00336 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!fill\+Song\+Data@{fill\+Song\+Data}}
\index{fill\+Song\+Data@{fill\+Song\+Data}!main.\+c@{main.\+c}}
\paragraph[{fill\+Song\+Data}]{\setlength{\rightskip}{0pt plus 5cm}void fill\+Song\+Data (
\begin{DoxyParamCaption}
\item[{{\bf data} $\ast$}]{data, }
\item[{int}]{hex[$\,$], }
\item[{int}]{numbers\+In\+Text}
\end{DoxyParamCaption}
)}\label{main_8c_a6406eca72b9402b7240ed0e453e8db46}
! A function, that fills out the song data 
\begin{DoxyParams}{Parameters}
{\em } & data$\ast$]\+: data\+: a pointer to a structure containing the tempo and mode of the song \\
\hline
{\em } & int]\+: hex[]\+:the array of integers read from the file \\
\hline
{\em } & int]\+: numbers\+In\+Text\+: the total amount of integers in the array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00216                                                            \{
00217   \textcolor{keywordtype}{int} j;
00218   \textcolor{comment}{/*Find the mode of the song, initialised as minor atm*/}
00219   \textcolor{keywordflow}{for}(j = 0; j < numbersInText; j++)\{
00220     \textcolor{comment}{/* finds the tempo */}
00221     \textcolor{keywordflow}{if}(hex[j] == 0xff && hex[j+1] == 0x51 && hex[j+2] == 0x03)\{
00222       data->tempo =  60000000/((hex[j+3] << 16) | (hex[j+4] << 8) | (hex[j+5]));
00223     \}
00224   \}
00225 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Events@{find\+Events}}
\index{find\+Events@{find\+Events}!main.\+c@{main.\+c}}
\paragraph[{find\+Events}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Events (
\begin{DoxyParamCaption}
\item[{int}]{numbers\+In\+Text, }
\item[{int}]{hex[$\,$], }
\item[{{\bf event\+Placement}}]{placement[$\,$], }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int}]{ticks[$\,$], }
\item[{int $\ast$}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_a958ac363192985c144e524cc6e092e7c}

\begin{DoxyCode}
00227                                                                                                            
           \{
00228   \textcolor{keywordtype}{int} noteOff = 0, noteOn = 0, afterTouch = 0, controlChange = 0,
00229       programChange = 0, channelPressure = 0, pitchWheel = 0, n = 0;
00230 
00231   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < numbersInText; j++)\{
00232     \textcolor{keywordflow}{switch} (hex[j])\{
00233       \textcolor{keywordflow}{case} 0x90: insertPlacement1(hex, &placement[noteOn++].noteOn, j, noteAr, &n);               \textcolor{keywordflow}{break};
00234       \textcolor{keywordflow}{case} 0x80: insertPlacement1(hex, &placement[noteOff++].noteOff, j, noteAr, &n);             \textcolor{keywordflow}{break};
00235       \textcolor{keywordflow}{case} 0xA0: insertPlacement1(hex, &placement[afterTouch++].afterTouch, j, noteAr, &n);       \textcolor{keywordflow}{break};
00236       \textcolor{keywordflow}{case} 0xB0: insertPlacement1(hex, &placement[controlChange++].controlChange, j, noteAr, &n); \textcolor{keywordflow}{break};
00237       \textcolor{keywordflow}{case} 0xC0: insertPlacement2(hex, &placement[programChange++].programChange, j);             \textcolor{keywordflow}{break};
00238       \textcolor{keywordflow}{case} 0xD0: insertPlacement2(hex, &placement[channelPressure++].channelPressure, j);         \textcolor{keywordflow}{break};
00239       \textcolor{keywordflow}{case} 0xE0: insertPlacement1(hex, &placement[pitchWheel++].pitchWheel, j, noteAr, &n);       \textcolor{keywordflow}{break};
00240       \textcolor{keywordflow}{default}  :                                                                                  \textcolor{keywordflow}{break};
00241     \}
00242   \}
00243   findTicks(numbersInText, hex, placement, noteAr, ticks, noteOn, size);
00244 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Mode@{find\+Mode}}
\index{find\+Mode@{find\+Mode}!main.\+c@{main.\+c}}
\paragraph[{find\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf note} $\ast$}]{, }
\item[{int}]{, }
\item[{{\bf data} $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_a16182e7956158cfcf78a8b97423ee1da}
\index{main.\+c@{main.\+c}!find\+Mode@{find\+Mode}}
\index{find\+Mode@{find\+Mode}!main.\+c@{main.\+c}}
\paragraph[{find\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Mode (
\begin{DoxyParamCaption}
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int}]{total\+Notes, }
\item[{{\bf data} $\ast$}]{data}
\end{DoxyParamCaption}
)}\label{main_8c_a660cd7ea9eae225a44ccb0fd609984a3}
A function to find the mode of the song by first calculating the tone span over sets of notes in the song, and then comparing it to the definition of minor and major keys. 
\begin{DoxyParams}{Parameters}
{\em } & note[]]\+: note\+Ar\+: An array of all the notes in the entire song \\
\hline
{\em } & int]\+: total\+Notes\+: The number of notes in the song \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00519                                                         \{
00520   \textcolor{keywordtype}{int} x = 0, y = 0, z = 0, bar[4], sizeBar = 4, tempSpan = 999, span = 999, keynote = 0, 
      mode = 0;
00521 
00522   \textcolor{comment}{/*Goes through all notes of the song and puts them into an array*/}
00523   \textcolor{keywordflow}{while}(x < totalNotes)\{
00524     \textcolor{keywordflow}{for}(y = 0; y < sizeBar; y++, x++)\{
00525       bar[y] = noteAr[x].tone;
00526     \}
00527 
00528     \textcolor{keywordflow}{if}(y == sizeBar)\{
00529       span = 999;
00530       \textcolor{comment}{/*Sort notes in acsending order*/}
00531       qsort(bar, sizeBar, \textcolor{keyword}{sizeof}(tone), sortTones);
00532 
00533       \textcolor{comment}{/*Find the lowest possible tonespan over the entire array of notes*/}
00534       \textcolor{keywordflow}{for}(z = 0; z < 4; z++)\{
00535     \textcolor{keywordflow}{if}((z + 1) > 3)
00536           tempSpan = (bar[(z+1)%4]+12)-bar[z] + bar[(z+2)%4]-bar[(z+1)%4] + bar[(z+3)%4]-bar[(z+2)%4];
00537         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((z + 2) > 3)
00538           tempSpan = bar[(z+1)]-bar[z] + (bar[(z+2)%4]+12)-bar[(z+1)%4] + bar[(z+3)%4]-bar[(z+2)%4];
00539     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((z +3) > 3)
00540           tempSpan = bar[(z+1)]-bar[z] + bar[(z+2)]-bar[(z+1)] + (bar[(z+3)%4]+12)-bar[z];
00541     \textcolor{keywordflow}{else}
00542           tempSpan = bar[(z+1)]-bar[z] + bar[(z+2)]-bar[(z+1)] + bar[(z+3)]-bar[(z+2)];
00543 
00544     \textcolor{keywordflow}{if}(tempSpan < span)\{
00545           span = tempSpan; 
00546           keynote = bar[z];
00547         \}
00548       \}
00549       mode += isInScale(keynote, bar, sizeBar);
00550       printf(\textcolor{stringliteral}{"Moden er nu: %d\(\backslash\)n"}, mode);
00551     \}
00552   data->key = keynote;
00553   \textcolor{keywordflow}{if}(mode > 0)
00554     data->mode = major;
00555   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mode < 0)
00556     data->mode = minor;  
00557   \}
00558 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!Find\+Mood\+Amount@{Find\+Mood\+Amount}}
\index{Find\+Mood\+Amount@{Find\+Mood\+Amount}!main.\+c@{main.\+c}}
\paragraph[{Find\+Mood\+Amount}]{\setlength{\rightskip}{0pt plus 5cm}int Find\+Mood\+Amount (
\begin{DoxyParamCaption}
\item[{F\+I\+L\+E $\ast$}]{moods}
\end{DoxyParamCaption}
)}\label{main_8c_aea24927f2da3a892904ec1abd4ad01bf}

\begin{DoxyCode}
00620                                \{
00621   \textcolor{keywordtype}{int} i = 1;
00622   \textcolor{keywordflow}{while}(fgetc(moods) != EOF)\{
00623     \textcolor{keywordflow}{if}(fgetc(moods) == \textcolor{charliteral}{'\(\backslash\)n'})
00624       i++;
00625   \}
00626   rewind(moods);
00627   \textcolor{keywordflow}{return} i;
00628 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!find\+Note\+Length@{find\+Note\+Length}}
\index{find\+Note\+Length@{find\+Note\+Length}!main.\+c@{main.\+c}}
\paragraph[{find\+Note\+Length}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Note\+Length (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{int $\ast$}]{, }
\item[{int $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_ab56a62ec1c82722ba291a717b2afca5b}
\index{main.\+c@{main.\+c}!find\+Ticks@{find\+Ticks}}
\index{find\+Ticks@{find\+Ticks}!main.\+c@{main.\+c}}
\paragraph[{find\+Ticks}]{\setlength{\rightskip}{0pt plus 5cm}void find\+Ticks (
\begin{DoxyParamCaption}
\item[{int}]{numbers\+In\+Text, }
\item[{int}]{hex[$\,$], }
\item[{{\bf event\+Placement}}]{placement[$\,$], }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int}]{ticks[$\,$], }
\item[{int}]{note\+On, }
\item[{int $\ast$}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_ac6acd514eb7de5e7d0a48cae55dc02ff}

\begin{DoxyCode}
00278                                                                                                            
                      \{
00279   \textcolor{keywordtype}{int} tickCounter = 0, deltaCounter1 = 3, deltaCounter2 = 2;
00280   
00281   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < noteOn; j++)\{
00282     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = placement[j].noteOn; i < numbersInText; i++)\{
00283       \textcolor{keywordflow}{if}(hex[i] == 0x80)\{
00284         \textcolor{keywordflow}{if}(hex[i + 1] == noteAr[j].tone)
00285           \textcolor{keywordflow}{break};
00286         \textcolor{keywordflow}{else}\{
00287           countTicks1(hex, &i, deltaCounter1, ticks, &tickCounter);
00288         \}
00289       \}
00290       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xA0)\{
00291         \textcolor{keywordflow}{if}(hex[i + 1] == noteAr[j].tone && hex[i + 2] == 0x00)
00292           \textcolor{keywordflow}{break};
00293         \textcolor{keywordflow}{else}\{
00294           countTicks1(hex, &i, deltaCounter1, ticks, &tickCounter);
00295         \}
00296       \}
00297       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xD0)\{
00298         \textcolor{keywordflow}{if}(hex[i + 1] == 0x00)
00299           \textcolor{keywordflow}{break};
00300         \textcolor{keywordflow}{else}\{
00301           countTicks2(hex, &i, deltaCounter2, ticks, &tickCounter);
00302         \}
00303       \}
00304       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(hex[i] == 0xC0)\{
00305         countTicks2(hex, &i, deltaCounter2, ticks, &tickCounter);
00306       \}
00307       \textcolor{keywordflow}{else}\{
00308         countTicks1(hex, &i, deltaCounter1, ticks, &tickCounter);
00309       \}     
00310     \}
00311   \}
00312 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!get\+Hex@{get\+Hex}}
\index{get\+Hex@{get\+Hex}!main.\+c@{main.\+c}}
\paragraph[{get\+Hex}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Hex (
\begin{DoxyParamCaption}
\item[{F\+I\+L\+E $\ast$}]{f, }
\item[{int}]{hex\+Ar[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_a7e86822405cc3ff43db316d113a1fb6d}
A function, that retrieves the hexadecimals from the files and also returns the number of files 
\begin{DoxyParams}{Parameters}
{\em } & F\+I\+L\+E$\ast$]\+: f\+: a pointer to the file the program is reading from \\
\hline
{\em } & int]\+: hex\+Ar[]\+: an array of integers, that the information is stored in \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00186                                 \{
00187   \textcolor{keywordtype}{int} i = 0, c;
00188   \textcolor{keywordflow}{while}( (c = fgetc(f)) != EOF && i < CHARS)\{
00189     hexAr[i] = c;
00190     i++;
00191   \}
00192   
00193   \textcolor{keywordflow}{return} i;
00194 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Moods@{insert\+Moods}}
\index{insert\+Moods@{insert\+Moods}!main.\+c@{main.\+c}}
\paragraph[{insert\+Moods}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Moods (
\begin{DoxyParamCaption}
\item[{{\bf mood\+Weighting}}]{mood\+Array[$\,$], }
\item[{F\+I\+L\+E $\ast$}]{moods}
\end{DoxyParamCaption}
)}\label{main_8c_a1709777308c32674291e7213d55feb6e}

\begin{DoxyCode}
00445                                                         \{
00446   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00447     fscanf(moods, \textcolor{stringliteral}{"%s %d %d %d %d"}, moodArray[i].name , &moodArray[i].mode, 
00448                                     &moodArray[i].tempo, &moodArray[i].toneLength,
00449                                     &moodArray[i].pitch);
00450   \}
00451 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Placement1@{insert\+Placement1}}
\index{insert\+Placement1@{insert\+Placement1}!main.\+c@{main.\+c}}
\paragraph[{insert\+Placement1}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Placement1 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{place, }
\item[{int}]{j, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{n}
\end{DoxyParamCaption}
)}\label{main_8c_afce19655c88726711949a8e720767874}

\begin{DoxyCode}
00246                                                                           \{
00247   \textcolor{keywordtype}{int} i = 3;
00248   \textcolor{keywordflow}{while}(i < 7 && hex[(j + i++)] > 0x80);
00249   \textcolor{keywordflow}{if}(checkNextEvent(hex, (j + i)))\{
00250     *place = j;
00251     \textcolor{keywordflow}{if}(hex[j] == 0x90)\{
00252       fillNote(hex[j + 1], &noteAr[*n]);
00253       *n += 1;
00254     \}   
00255   \} 
00256 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!insert\+Placement2@{insert\+Placement2}}
\index{insert\+Placement2@{insert\+Placement2}!main.\+c@{main.\+c}}
\paragraph[{insert\+Placement2}]{\setlength{\rightskip}{0pt plus 5cm}void insert\+Placement2 (
\begin{DoxyParamCaption}
\item[{int}]{hex[$\,$], }
\item[{int $\ast$}]{place, }
\item[{int}]{j}
\end{DoxyParamCaption}
)}\label{main_8c_a0349131ee04fd791a9bcd1205db44778}

\begin{DoxyCode}
00258                                                    \{
00259   \textcolor{keywordtype}{int} i = 2;
00260   \textcolor{keywordflow}{while}(i < 6 && hex[(j + i++)] > 0x80);
00261   \textcolor{keywordflow}{if}(checkNextEvent(hex, (j + i)))
00262     *place = j;
00263 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Major@{is\+In\+Major}}
\index{is\+In\+Major@{is\+In\+Major}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Major}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Major (
\begin{DoxyParamCaption}
\item[{int}]{tone\+Leap}
\end{DoxyParamCaption}
)}\label{main_8c_a241d0a265bf9c508dee8671ecab5f1d8}
A function to check if the given tone leap is in the major scale. 
\begin{DoxyParams}{Parameters}
{\em } & int]\+: tone\+Leap\+: An integer describing the processed tone leap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
[ int]\+: a boolean value, returns 1 if the tone leap is in the major scale, 0 if it's not. 
\end{DoxyReturn}

\begin{DoxyCode}
00610                            \{
00611   \textcolor{keywordtype}{int} major[] = \{0, 2, 4, 5, 7, 9, 11\};
00612 
00613   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < SCALESIZE; i++)\{
00614     \textcolor{keywordflow}{if}(toneLeap == major[i])
00615       \textcolor{keywordflow}{return} 1;
00616   \}
00617   \textcolor{keywordflow}{return} 0;
00618 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Minor@{is\+In\+Minor}}
\index{is\+In\+Minor@{is\+In\+Minor}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Minor}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Minor (
\begin{DoxyParamCaption}
\item[{int}]{tone\+Leap}
\end{DoxyParamCaption}
)}\label{main_8c_a7a1c0b6f906689e24cb60e1e5ff8bc76}
A function to check if the given tone leap is in the minor scale. 
\begin{DoxyParams}{Parameters}
{\em } & int]\+: tone\+Leap\+: An integer describing the processed tone leap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
[ int]\+: a boolean value, returns 1 if the tone leap is in the minor scale, 0 if it's not. 
\end{DoxyReturn}

\begin{DoxyCode}
00596                            \{
00597   \textcolor{keywordtype}{int} minor[] = \{0, 2, 3, 5, 7, 8, 10\};
00598 
00599   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < SCALESIZE; i++)\{
00600     \textcolor{keywordflow}{if}(toneLeap == minor[i])
00601       \textcolor{keywordflow}{return} 1;
00602   \}
00603   \textcolor{keywordflow}{return} 0;
00604 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!is\+In\+Scale@{is\+In\+Scale}}
\index{is\+In\+Scale@{is\+In\+Scale}!main.\+c@{main.\+c}}
\paragraph[{is\+In\+Scale}]{\setlength{\rightskip}{0pt plus 5cm}int is\+In\+Scale (
\begin{DoxyParamCaption}
\item[{int}]{keytone, }
\item[{int}]{other\+Tones[$\,$], }
\item[{int}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_ab07d21079009fe6f42cd1a95b5db3522}
A function to check if a given scale in given keytone corresponds with the tones in the rest of the song. 
\begin{DoxyParams}{Parameters}
{\em } & scale]\+: mode\+: An enum that describes the given mode \\
\hline
{\em } & int]\+: keytone\+: The keytone of the processed scale \\
\hline
{\em } & int]\+: other\+Tones[]\+: An array of the rest of the tones, which the function compares to the keytone and mode \\
\hline
{\em } & int]\+: size\+: The number of tones in the other\+Tones array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
[ int]\+: a boolean value, returns 1 if the mode is major, -\/1 if it's minor and 0, if wasn't possible to decide. 
\end{DoxyReturn}

\begin{DoxyCode}
00567                                                       \{
00568   \textcolor{keywordtype}{int} toneLeap, isMinor = 1, isMajor = 1;
00569 
00570   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++)\{
00571     \textcolor{keywordflow}{if}(otherTones[i] < keytone)
00572       otherTones[i] += 12;
00573       toneLeap = otherTones[i] - keytone;
00574 
00575       \textcolor{keywordflow}{if}(isMinor)
00576         isMinor = isInMinor(toneLeap);
00577       \textcolor{keywordflow}{if}(isMajor)
00578         isMajor = isInMajor(toneLeap);
00579     \}
00580 
00581     \textcolor{keywordflow}{if}(isMinor && isMajor)
00582       \textcolor{keywordflow}{return} 0;
00583     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(isMinor)
00584       \textcolor{keywordflow}{return} -1;
00585     \textcolor{keywordflow}{if}(isMajor)
00586       \textcolor{keywordflow}{return} 1;
00587 
00588     \textcolor{keywordflow}{return} 0;
00589 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!main@{main}}
\index{main@{main}!main.\+c@{main.\+c}}
\paragraph[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{const char $\ast$}]{argv[$\,$]}
\end{DoxyParamCaption}
)}\label{main_8c_ac0f2228420376f4db7e1274f2b41667c}

\begin{DoxyCode}
00094                                       \{
00095   FILE *f;
00096   \textcolor{keywordtype}{char} MIDIfile[25];
00097   \textcolor{comment}{/*Variables*/}
00098   \textcolor{keywordtype}{int} numbersInText = 0, notes, i = 0, size = 0, moodOfMelodi = 0;
00099   \textcolor{comment}{/* PLACEHOLDER FIX THIS */}
00100   \textcolor{keywordtype}{int} mode = 5, tempo = 5, toneLength = 5, pitch = 5;
00101   FILE* moods = fopen(\textcolor{stringliteral}{"moods.txt"}, \textcolor{stringliteral}{"r"});
00102   \textcolor{keywordflow}{if}(moods == NULL)\{
00103     perror(\textcolor{stringliteral}{"Error: moods missing "});
00104     exit(EXIT\_FAILURE);
00105   \}
00106   AMOUNT_OF_MOODS = FindMoodAmount(moods);
00107   moodWeighting moodArray[AMOUNT_OF_MOODS];
00108   data data = \{0, major, D\};
00109   \textcolor{keywordflow}{if} (argv[1] == NULL)\{
00110     checkDirectory(MIDIfile);  
00111     f = fopen(MIDIfile,\textcolor{stringliteral}{"r"});  
00112     \textcolor{keywordflow}{if}(f == NULL)\{
00113       perror(\textcolor{stringliteral}{"Error opening file"});
00114       exit(EXIT\_FAILURE);
00115     \}
00116   \}
00117   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(argv[1] != NULL)\{
00118     f = fopen(argv[1],\textcolor{stringliteral}{"r"});
00119     \textcolor{keywordflow}{if}(f == NULL)\{
00120       perror(\textcolor{stringliteral}{"Error opening file"});
00121       exit(EXIT\_FAILURE);
00122     \}
00123   \}
00124 
00125   \textcolor{keywordtype}{int} *hex = (\textcolor{keywordtype}{int} *) malloc(CHARS * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00126   \textcolor{keywordflow}{if}(hex == NULL)\{
00127     printf(\textcolor{stringliteral}{"Memory allocation failed, bye!"});
00128     exit(EXIT\_FAILURE);
00129   \}
00130   \textcolor{comment}{/*Reading the data from the file*/}
00131   numbersInText = getHex(f, hex);
00132   fillSongData(&data, hex, numbersInText);
00133   notes = countNotes(hex, numbersInText);
00134   note *noteAr = (note*) malloc(notes * \textcolor{keyword}{sizeof}(note));
00135   \textcolor{keywordflow}{if}(noteAr == NULL)\{
00136     printf(\textcolor{stringliteral}{"Memory allocation failed, bye!"});
00137     exit(EXIT\_FAILURE);
00138   \}
00139   eventPlacement placement[numbersInText];
00140   \textcolor{keywordtype}{int} ticks[numbersInText];
00141   findEvents(numbersInText, hex, placement, noteAr, ticks, &size);
00142   insertMoods(moodArray, moods);
00143   settingPoints(&mode, &tempo, &toneLength, &pitch, data, notes, noteAr, &size);
00144   printf(\textcolor{stringliteral}{"%d, %d, %d, %d\(\backslash\)n"}, mode, tempo, toneLength, pitch);
00145   \textcolor{keywordflow}{for}(i = 0; i < notes; i++)
00146     printNote(noteAr[i]);
00147   findMode(noteAr, notes, &data);
00148   printSongData(data);
00149   moodOfMelodi = weightingMatrix(moodArray, mode, tempo, toneLength, pitch);
00150   printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, moodOfMelodi);
00151 
00152 
00153   \textcolor{comment}{/*Clean up and close*/}
00154   fclose(f);
00155   free(hex);
00156   free(noteAr);
00157 
00158   \textcolor{keywordflow}{return} 0;
00159 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!print\+Note@{print\+Note}}
\index{print\+Note@{print\+Note}!main.\+c@{main.\+c}}
\paragraph[{print\+Note}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Note (
\begin{DoxyParamCaption}
\item[{{\bf note}}]{note}
\end{DoxyParamCaption}
)}\label{main_8c_aa9c735ae880cee4e1272bcf387462c9a}
A function to print the note 
\begin{DoxyParams}{Parameters}
{\em } & note]\+: note\+: the note structure to be printed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00341                          \{
00342   printf(\textcolor{stringliteral}{"Tone: "});
00343 
00344   \textcolor{keywordflow}{switch} (note.tone)\{
00345     \textcolor{keywordflow}{case} C     : printf(\textcolor{stringliteral}{"C"}) ; \textcolor{keywordflow}{break};
00346     \textcolor{keywordflow}{case} Csharp: printf(\textcolor{stringliteral}{"C#"}); \textcolor{keywordflow}{break};
00347     \textcolor{keywordflow}{case} D     : printf(\textcolor{stringliteral}{"D"}) ; \textcolor{keywordflow}{break};
00348     \textcolor{keywordflow}{case} Dsharp: printf(\textcolor{stringliteral}{"D#"}); \textcolor{keywordflow}{break};
00349     \textcolor{keywordflow}{case} E     : printf(\textcolor{stringliteral}{"E"}) ; \textcolor{keywordflow}{break};
00350     \textcolor{keywordflow}{case} F     : printf(\textcolor{stringliteral}{"F"}) ; \textcolor{keywordflow}{break};
00351     \textcolor{keywordflow}{case} Fsharp: printf(\textcolor{stringliteral}{"F#"}); \textcolor{keywordflow}{break};
00352     \textcolor{keywordflow}{case} G     : printf(\textcolor{stringliteral}{"G"}) ; \textcolor{keywordflow}{break};
00353     \textcolor{keywordflow}{case} Gsharp: printf(\textcolor{stringliteral}{"G#"}); \textcolor{keywordflow}{break};
00354     \textcolor{keywordflow}{case} A     : printf(\textcolor{stringliteral}{"A"}) ; \textcolor{keywordflow}{break};
00355     \textcolor{keywordflow}{case} Asharp: printf(\textcolor{stringliteral}{"A#"}); \textcolor{keywordflow}{break};
00356     \textcolor{keywordflow}{case} B     : printf(\textcolor{stringliteral}{"B"}) ; \textcolor{keywordflow}{break};
00357     \textcolor{keywordflow}{default}    : printf(\textcolor{stringliteral}{"Undefined note"}); \textcolor{keywordflow}{break};
00358   \}
00359   printf(\textcolor{stringliteral}{", octave: %d\(\backslash\)n"}, note.octave);
00360 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!print\+Song\+Data@{print\+Song\+Data}}
\index{print\+Song\+Data@{print\+Song\+Data}!main.\+c@{main.\+c}}
\paragraph[{print\+Song\+Data}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Song\+Data (
\begin{DoxyParamCaption}
\item[{{\bf data}}]{data}
\end{DoxyParamCaption}
)}\label{main_8c_a96686ff783072b26aa8666d0281d053c}
A function to print out the overall data of the song, tempo and mode 
\begin{DoxyParams}{Parameters}
{\em } & data]\+: data\+: the data to be printed \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
00365                              \{
00366   printf(\textcolor{stringliteral}{"Tempo: %d\(\backslash\)nMode: "}, data.tempo);
00367   \textcolor{keywordflow}{switch}(data.mode)\{
00368     \textcolor{keywordflow}{case} minor: printf(\textcolor{stringliteral}{"minor"}); \textcolor{keywordflow}{break};
00369     \textcolor{keywordflow}{case} major: printf(\textcolor{stringliteral}{"major"}); \textcolor{keywordflow}{break};
00370     \textcolor{keywordflow}{default}: printf(\textcolor{stringliteral}{"unknown mode"}); \textcolor{keywordflow}{break};
00371   \}
00372   printf(\textcolor{stringliteral}{"\(\backslash\)nKeytone: %d"}, data.key);
00373   putchar(\textcolor{charliteral}{'\(\backslash\)n'});
00374 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!setting\+Points@{setting\+Points}}
\index{setting\+Points@{setting\+Points}!main.\+c@{main.\+c}}
\paragraph[{setting\+Points}]{\setlength{\rightskip}{0pt plus 5cm}void setting\+Points (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{mode, }
\item[{int $\ast$}]{tempo, }
\item[{int $\ast$}]{length, }
\item[{int $\ast$}]{octave, }
\item[{{\bf data}}]{data, }
\item[{int}]{notes, }
\item[{{\bf note}}]{note\+Ar[$\,$], }
\item[{int $\ast$}]{size}
\end{DoxyParamCaption}
)}\label{main_8c_ac5cf65542ee2eded456a070d2159af90}

\begin{DoxyCode}
00376                                                                                                            
              \{
00377   \textcolor{keywordtype}{int} deltaTime = 2, combined = 0, averageNote = 0;
00378   \textcolor{keywordflow}{switch}(data.mode)\{
00379     \textcolor{keywordflow}{case} minor: *mode = -5; \textcolor{keywordflow}{break};
00380     \textcolor{keywordflow}{case} major: *mode = 5; \textcolor{keywordflow}{break};
00381     \textcolor{keywordflow}{default}: *mode = 0; \textcolor{keywordflow}{break};
00382   \}
00383   \textcolor{keywordflow}{if}(data.tempo < 60)
00384     *tempo = -5;
00385   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 60 && data.tempo < 70)
00386     *tempo = -4;
00387   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 70 && data.tempo < 80)
00388     *tempo = -3;  
00389   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 80 && data.tempo < 90)
00390     *tempo = -2;
00391   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 90 && data.tempo < 100)
00392     *tempo = -1;
00393   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 100 && data.tempo < 120)
00394     *tempo =  0;  
00395   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 120 && data.tempo < 130)
00396     *tempo =  1;
00397   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 130 && data.tempo < 140)
00398     *tempo =  2;
00399   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 140 && data.tempo < 150)
00400     *tempo =  3;
00401   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >= 150 && data.tempo < 160)
00402     *tempo =  4;
00403   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(data.tempo >=  160)
00404     *tempo =  5;
00405 
00406   \textcolor{keywordflow}{switch}(deltaTime)\{
00407     \textcolor{keywordflow}{case} 1: *length = -5; \textcolor{keywordflow}{break};
00408     \textcolor{keywordflow}{case} 2: *length = -4; \textcolor{keywordflow}{break};
00409     \textcolor{keywordflow}{case} 4: *length = -2; \textcolor{keywordflow}{break};
00410     \textcolor{keywordflow}{case} 8: *length =  0; \textcolor{keywordflow}{break};
00411     \textcolor{keywordflow}{case} 16: *length = 3; \textcolor{keywordflow}{break};
00412     \textcolor{keywordflow}{case} 32: *length = 5; \textcolor{keywordflow}{break};
00413   \}
00414   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < notes; i++)\{
00415     combined += noteAr[i].average;
00416   \}
00417   averageNote = combined/notes;
00418 
00419   \textcolor{keywordflow}{if}(averageNote <= 16)
00420     *octave = -5;
00421   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 17 && averageNote <= 23)
00422     *octave = -4;
00423   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 24 && averageNote <= 30)
00424     *octave = -3;
00425   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 31 && averageNote <= 37)
00426     *octave = -2;
00427   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 38 && averageNote <= 44)
00428     *octave = -1;
00429   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 45 && averageNote <= 51)
00430     *octave = 0;
00431   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 52 && averageNote <= 58)
00432     *octave = 1;
00433   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 59 && averageNote <= 65)
00434     *octave = 2;
00435   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 66 && averageNote <= 72)
00436     *octave = 3;
00437   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >= 73 && averageNote <= 79)
00438     *octave = 4;
00439   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(averageNote >=80)
00440     *octave = 5;
00441 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!sort\+Result@{sort\+Result}}
\index{sort\+Result@{sort\+Result}!main.\+c@{main.\+c}}
\paragraph[{sort\+Result}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Result (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{pa, }
\item[{const void $\ast$}]{pb}
\end{DoxyParamCaption}
)}\label{main_8c_ac6a3184d104e99d57824eecaabab8ed5}

\begin{DoxyCode}
00477                                               \{
00478   \textcolor{keywordtype}{int} a = *(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*)pa;
00479   \textcolor{keywordtype}{int} b = *(\textcolor{keyword}{const} \textcolor{keywordtype}{int}*)pb;
00480   \textcolor{keywordflow}{return} (b-a);
00481 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!sort\+Toner@{sort\+Toner}}
\index{sort\+Toner@{sort\+Toner}!main.\+c@{main.\+c}}
\paragraph[{sort\+Toner}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Toner (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{, }
\item[{const void $\ast$}]{}
\end{DoxyParamCaption}
)}\label{main_8c_a27beb09cf7217b8c5f3789913aa857db}
\index{main.\+c@{main.\+c}!sort\+Tones@{sort\+Tones}}
\index{sort\+Tones@{sort\+Tones}!main.\+c@{main.\+c}}
\paragraph[{sort\+Tones}]{\setlength{\rightskip}{0pt plus 5cm}int sort\+Tones (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}\label{main_8c_a33b74ebb6acaeb30576c9e66aebe2fb6}
A function to sort integers in ascending order. 
\begin{DoxyCode}
00509                                            \{
00510   \textcolor{keywordtype}{int} *i1 = (\textcolor{keywordtype}{int}*) a, *i2 = (\textcolor{keywordtype}{int}*) b;
00511 
00512   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int}) *i1 - *i2;
00513 \}
\end{DoxyCode}
\index{main.\+c@{main.\+c}!weighting\+Matrix@{weighting\+Matrix}}
\index{weighting\+Matrix@{weighting\+Matrix}!main.\+c@{main.\+c}}
\paragraph[{weighting\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}int weighting\+Matrix (
\begin{DoxyParamCaption}
\item[{{\bf mood\+Weighting}}]{mood\+Array[$\,$], }
\item[{int}]{mode, }
\item[{int}]{tempo, }
\item[{int}]{tone\+Length, }
\item[{int}]{pitch}
\end{DoxyParamCaption}
)}\label{main_8c_ade6b8acc6a7f498b910c155b43d442b1}

\begin{DoxyCode}
00454                                                                                               \{
00455   \textcolor{keywordtype}{int} result[AMOUNT_OF_MOODS];
00456   
00457   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00458     result[i] = 0;
00459   \}
00460   
00461   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00462     result[i] += (moodArray[i].mode * mode);
00463     result[i] += (moodArray[i].tempo * tempo);
00464     result[i] += (moodArray[i].toneLength * toneLength);
00465     result[i] += (moodArray[i].pitch * pitch);
00466   \}
00467   
00468   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < AMOUNT_OF_MOODS; i++)\{
00469     printf(\textcolor{stringliteral}{"%s: %d\(\backslash\)n"}, moodArray[i].name, result[i]);
00470   \}
00471   
00472   qsort(result, AMOUNT\_OF\_MOODS, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), sortResult);
00473   \textcolor{keywordflow}{return} result[0];
00474 \}
\end{DoxyCode}


\subsubsection{Variable Documentation}
\index{main.\+c@{main.\+c}!A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S@{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}}
\index{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S@{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}!main.\+c@{main.\+c}}
\paragraph[{A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}]{\setlength{\rightskip}{0pt plus 5cm}int A\+M\+O\+U\+N\+T\+\_\+\+O\+F\+\_\+\+M\+O\+O\+D\+S}\label{main_8c_ad4daca5a141533e7c95216763e28c4fe}
